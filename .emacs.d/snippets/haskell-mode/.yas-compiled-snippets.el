;;; Compiled snippets and support files for `haskell-mode'
;;; Snippet definitions:
;;;
(yas-define-snippets 'haskell-mode
                     '(("$" "($) :: (a -> b) -> a -> b\nf $ x = f x" "$" nil nil nil nil nil nil)
                       ("&&" "(&&)                    :: Bool -> Bool -> Bool\nTrue  && x              =  x\nFalse && _              =  False" "&&" nil nil nil nil nil nil)
                       ("++" "(++) :: [a] -> [a] -> [a]\n[] ++ xs = xs\n(x:xs) ++ (ys) = x : xs ++ ys\n" "++" nil nil nil nil nil nil)
                       ("<=<" "(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c\n(<=<) = flip (>=>)" "<=<" nil nil nil nil nil nil)
                       ("=<<" "(=<<) :: Monad m => (a -> m b) -> m a -> m b\nf =<< m = m >>= f" "=<<" nil nil nil nil nil nil)
                       (">=>" "(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c\nf >=> g = \\x -> f x >>= g" ">=>" nil nil nil nil nil nil)
                       (">>=" "(>>=) :: ${1:Monad} a -> (a -> $1 b) -> $1 b" ">>=" nil nil nil nil nil nil)
                       ("App" "Applicative" "App" nil nil
                        ((yas-indent-line 'fixed))
                        nil nil nil)
                       ("Endo" "newtype Endo a = Endo { appEndo :: a -> a }" "Endo" nil nil nil nil nil nil)
                       ("First" "newtype First a = First { getFirst :: Maybe a }" "First" nil nil nil nil nil nil)
                       ("Kleisli" "newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }" "Kleisli" nil nil nil nil nil nil)
                       ("S" "Show" "S" nil nil nil nil nil nil)
                       ("acidserver" "main :: IO ()\nmain = bracket (openLocalState $ ${1:State})\n       closeAcidState $ acidServer skipAuthenticationCheck (PortNumber ${2:Port})" "acidserver" nil nil nil nil nil nil)
                       ("addM" "addM :: Num a => Maybe a -> Maybe a -> Maybe a\naddM mx my | Just x <- mx, Just y <- my = Just $ x + y\naddM _ _ = Nothing" "addM" nil nil nil nil nil nil)
                       ("ah" "# -*- mode: snippet -*-\n# name: ah\n# key: ah\n# author: dmjio\n$1 :: Handler App (AuthManager App) ()\n$1 = method $2 handle$2\n  where handle$2 = currentUser >>= maybe the404 handleUser\n        handleUser AuthUser{..} = do\n           if Role \"admin\" `elem` userRoles\n              then do $3\n              else the404" "ah" nil nil nil nil nil nil)
                       ("all" "all :: (a -> Bool) -> [a] -> Bool\nall _ []     = True\nall p (x:xs) = p x && all p xs\n" "all" nil nil nil nil nil nil)
                       ("alternative" "class Applicative f => Alternative f where\n    empty :: f a\n    (<|>) :: f a -> f a -> f a\n\n    -- | One or more\n    some :: f a -> f [a]\n    some v = some_v where\n        many_v = some_v <|> pure []\n        some_v = (:) <$ > v <*> many_v\n\n    -- | Zero or more\n    many :: f a -> f [a]\n    many v = many_v where\n        many_v = some_v <|> pure []\n        some_v = (:) <$ > v <*> many_v" "alternative" nil nil nil nil nil nil)
                       ("alternativeidentityt" "instance (Alternative m) => Alternative (IdentityT m) where\n    empty = IdentityT empty\n    (<|>) = lift2IdentityT (<|>)" "alternativeidentityt" nil nil nil nil nil nil)
                       ("alternativet" "instance (Alternative m) => Alternative (${1:Type}T m) where\n    empty = $1T empty\n    (<|>) = $2\n    " "alternativet" nil nil nil nil nil nil)
                       ("altlist" "instance Alternative [] where\n    empty = []\n    (<|>) = concat" "altlist" nil nil nil nil nil nil)
                       ("altmaybe" "instance Alternative Maybe where\n    empty = Nothing\n    Nothing <|> r = r\n    l <|> _       = l" "altmaybe" nil nil nil nil nil nil)
                       ("an" "-- | " "an" nil nil nil nil nil nil)
                       ("and" "and :: [Bool] -> Bool -- foldr (&&) True\nand [] = True\nand (x:xs) = x && (and xs)\n\n" "and" nil nil nil nil nil nil)
                       ("any" "any :: (a -> Bool) -> [a] -> Bool\nany f [] = False\nany f (x:xs) = f x || any f xs\n" "any" nil nil nil nil nil nil)
                       ("ap" "ap :: Monad m => m (a -> b) -> m a -> m b\nap mf ma = do\n  f <- mf\n  x <- ma\n  return $ f x" "ap" nil nil nil nil nil nil)
                       ("applicative" "infixl 4 <*>\nclass Applicative f where\n    pure :: a -> f a\n    (<*>) :: f (a -> b) -> f a -> f b\n" "applicative" nil nil
                        ((yas-indent-line 'fixed))
                        nil nil nil)
                       ("appe" "instance Applicative ((->) e) where\n    pure y = \\x -> y\n    f <*> g = \\x -> f x (g x)" "appe" nil nil nil nil nil nil)
                       ("applicativeidentityt" "instance (Applicative m) => Applicative (IdentityT m) where\n    pure x = IdentityT (pure x)\n    (<*>) = lift2IdentityT (<*>)" "applicativeidentityt" nil nil nil nil nil nil)
                       ("applicativelaws" "--Identity: pure id <*> v = v\n--Homomorphism: pure f <*> pure x = pure (f x)\n--Interchange: u <*> pure y = pure ($ y) <*> u\n--Composition: u <*> (v <*> w) = pure (.) <*> u <*> v <*> w" "applicativelaws" nil nil nil nil nil nil)
                       ("applicativet" "instance (Applicative m) => Applicative (${1:Class}T m) where\n    pure x = $1T $2\n    (<*>) = $3\n    " "applicativet" nil nil nil nil nil nil)
                       ("applist" "instance Applicative [] where\n    pure x = [x]\n    ff <*> fx = [ f x | f <- ff, x <- fx ]" "applist" nil nil nil nil nil nil)
                       ("appmaybe" "instance Applicative Maybe where\n    pure = return\n    (<*>) = ap\n" "appmaybe" nil nil nil nil nil nil)
                       ("appziplist" "instance Applicative ZipList where\n    pure x = ZipList (repeat x)\n    ZipList fs <*> ZipList xs = ZipList $ zipWith ($) fs xs\n" "appziplist" nil nil nil nil nil nil)
                       ("arrayio" "main = do arr <- newArray (1,10) 37 :: IO (IOArray Int Int)\n          a <- readArray arr 1\n          writeArray arr 1 64\n          b <- readArray arr 1\n          print (a, b)\n" "arrayio" nil nil nil nil nil nil)
                       ("arrow" "class Category a => Arrow a where\n  arr   :: (b -> c) -> a b c\n  (>>>) :: a b c -> a c d -> a b d\n  first :: a b c -> a (b, d) (c, d)\n  (***) :: a b c -> a b' c' -> a (b, b') (c, c')\n  (&&&) :: a b c -> a b c' -> a b (c, c')\n" "arrow" nil nil nil nil nil nil)
                       ("arrowplus" "class Arrow a => ArrowZero a where\n    zeroArrow :: a b c\n\nclass ArrowZero a => ArrowPlus a where\n    (<+>) :: a b c -> a b c -> a b c\n            " "arrowplus" nil nil nil nil nil nil)
                       ("b" "${1:name} ${2:arg} = ${3:[]}" "b" nil nil nil nil nil nil)
                       ("bas" "bindAttributeSplices" "bas" nil nil nil nil nil nil)
                       ("bbb" "import Blaze.ByteString.Builder" "bbb" nil nil nil nil nil nil)
                       ("bbbe" "import Blaze.ByteString.Builder.Enumerator" "bbbe" nil nil nil nil nil nil)
                       ("bc" "import qualified Data.ByteString.Char8 as BC\n" "bc" nil nil nil nil nil nil)
                       ("binarysearch" "binarySearch :: (Integral a, Ord b, Ix a) => \n             Array a b -> b -> a -> a -> Maybe a\nbinarySearch xs num lo hi\n    | hi < lo = Nothing\n    | pivot > num = binarySearch xs num lo (mid-1)\n    | pivot < num = binarySearch xs num (mid+1) hi\n    | otherwise= Just mid\n       where\n         mid= lo + (hi-lo) div 2\n         pivot= xs!mid" "binarysearch" nil nil nil nil nil nil)
                       ("bitonic" "import           Control.Monad (forM_)\nimport           Data.Sequence\nimport           Prelude       hiding (drop, head, last, length,\nsplitAt, take)\n\n-- Finger Tree (aka Palm Tree) used to find max values in a bitonic\n   sequence\nbitonic :: (Ord a, Num a) => Seq a -> a\nbitonic x | x == empty    = error \"Empty sequence\"\n          | length x == 1 = index x 0\n          | otherwise     = let (l, m, r) = splitter x\n                            in handle l m r\n\n-- * O(log(min(i,n-i))) due to splitAt, take, drop. length is O(1)\nsplitter :: Seq a -> (Seq a, a, Seq a)\nsplitter x = (left, mid, right)\n  where\n    (left,r) = splitAt ((`div` 2) . length $ x) x\n    (mid,right) = (index (take 1 r) 0, drop 1 r)\n\n-- * O(log(min(i,n-i))) -- length is O(1) and index O(log(min(i,n-i)))\nlast :: Seq a -> a\nlast xs = let len = length xs in index xs (len-1)\n\n-- * O(log(min(i,n-i)))\nhead :: Seq a -> a\nhead xs = index xs 0\n\n-- * O(log(min(i,n-i))) due to head\nhandle :: (Ord a, Num a) => Seq a -> a -> Seq a -> a\nhandle left x right\n       | last left > x && x > y = bitonic $ left |> x\n       | last left < x && x < y = bitonic $ x <| right\n       | last left < x && x > y = x\n  where y = head right\nhandle _ _ _ = error \"your sequence isn't bitonic\"\n\ntests :: [[Int]]\ntests  =\n[[9],[1,2,3,4,5,6,7,8,9,8,7],[1,2,3,4,5,6,7,8,9,8,7,6],[1,2,3,4,3,2,1],[]]\n\nmain :: IO ()\nmain = forM_ tests (print . bitonic . fromList)" "bitonic" nil nil nil nil nil nil)
                       ("bl" "import qualified Data.ByteString.Lazy as BL\n" "bl" nil nil nil nil nil nil)
                       ("blazeexample" "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main where\n\nimport           Control.Monad                   (forM_)\n\nimport           Text.Blaze.Html.Renderer.Pretty\nimport           Text.Blaze.Html5                as H\n\nmain :: IO ()\nmain = writeFile \"index.html\" writer\n\nwriter :: String\nwriter = renderHtml $ numbers 3\n\nnumbers :: Int -> Html\nnumbers n = docTypeHtml $ do\n              H.head $ H.title \"Natural Numbers\"\n              body $ do\n                p \"A list of natural numbers\"\n                ul $ forM_ [1 .. n] (li . toHtml)\n" "blazeexample" nil nil nil nil nil nil)
                       ("blc" "import qualified Data.ByteString.Lazy.Char8 as BLC\n" "blc" nil nil nil nil nil nil)
                       ("bool" "data Bool = True | False" "bool" nil nil nil nil nil nil)
                       ("bp" "{-#LANGUAGE BangPatterns#-}" "bp" nil nil nil nil nil nil)
                       ("bracketex" "import           Control.Concurrent\nimport           Control.Exception\nimport           Control.Monad\n\nsecs :: Int -> Int\nsecs = (*1000000)\n\nmain :: IO ()\nmain = bracket start\n               finish\n               middle\n  where start = getLine\n        finish arg = do\n          putStrLn arg\n          putStrLn \"done\"\n        middle _ = forever $ do\n          threadDelay $ secs 1\n          putStrLn \"running\"\n" "bracketex" nil nil nil nil nil nil)
                       ("bs" "import qualified Data.ByteString as B\n" "bs" nil nil nil nil nil nil)
                       ("bs64" "import Data.ByteString.Base64 (encode, decode)\n" "bs64" nil nil nil nil nil nil)
                       ("bsperf" "import qualified Data.ByteString.Char8 as B\nimport           Data.Maybe\n\nmain :: IO ()\nmain = try\n\ntry :: IO () -- 0.17 seconds\ntry = readFile \"/usr/share/dict/words\" >>= putStrLn . last . lines\n\nbstry :: IO () --0.015 seconds\nbstry = B.readFile \"/usr/share/dict/words\" >>= B.putStrLn . last . B.lines\n" "bsperf" nil nil nil nil nil nil)
                       ("bst" "data STree a = Empty | Split a (STree a) (STree a)" "bst" nil nil nil nil nil nil)
                       ("bubblesort" "import           Data.List       (sort)\nimport           Test.QuickCheck\n\nmain :: IO ()\nmain = do verboseCheck isValidSort >> verboseCheck idempotent\n\nisValidSort, idempotent :: [Integer] -> Bool\nisValidSort xs = sort xs == bubbleSort xs\nidempotent  xs = bubbleSort (bubbleSort xs) == bubbleSort xs\n\nbubbleSort :: [Integer] -> [Integer]\nbubbleSort xs = let (state, bubbled) = bubble True xs\n                in if not state\n                   then bubbleSort bubbled\n                   else bubbled\n  where\n    bubble :: Bool -> [Integer] -> (Bool, [Integer])\n    bubble changed []  = (,) changed []\n    bubble changed [x] = (,) changed [x]\n    bubble changed (a:b:as) | compare a b == GT = (fst $ bubble False (a:as), b:(snd $ bubble False (a:as)))\n                            | otherwise = (fst $ bubble (changed && True) (b:as), a:(snd $ bubble (changed && True) (b:as)))\n" "bubblesort" nil nil nil nil nil nil)
                       ("nobuff" "hSetBuffering h NoBuffering" "nobuff" nil nil nil nil nil nil)
                       ("ca" "import           Control.Applicative\n" "ca" nil nil nil nil nil nil)
                       ("car" "import Control.Arrow\n" "car" nil nil nil nil nil nil)
                       ("case" "case ${1:x} of\n    ${2:Data} -> ${4:expression}\n${3:Data} -> ${5:expression}$0" "case" nil nil
                        ((yas-indent-line 'fixed))
                        nil nil nil)
                       ("catMaybes" "catMaybes :: [Maybe a] -> [a]\ncatMaybes ls = [l | Just l <- ls ]\n" "catMaybes" nil nil nil nil nil nil)
                       ("cata" "type Algebra f a = f a -> a\nnewtype Mu f = InF { outF :: f (Mu f) }\ncata :: Functor f => Algebra f a -> Mu f -> a\ncata f = f . fmap (cata f) . outF" "cata" nil nil nil nil nil nil)
                       ("category" "class Category cat where\n  id :: cat a a\n  (.) :: cat b c -> cat a b -> cat a c\n" "category" nil nil nil nil nil nil)
                       ("caz" "import Codec.Archive.Zip" "caz" nil nil nil nil nil nil)
                       ("cc" "import Control.Category\n" "cc" nil nil nil nil nil nil)
                       ("cca" "import Control.Concurrent.Async" "cca" nil nil nil nil nil nil)
                       ("ccg" "import Codec.Compression.GZip" "ccg" nil nil nil nil nil nil)
                       ("cch" "import Control.Concurrent.Chan" "cch" nil nil nil nil nil nil)
                       ("ccmv" "import Control.Concurrent.MVar" "ccmv" nil nil nil nil nil nil)
                       ("ccmvar" "import Control.Concurrent.MVar" "ccmvar" nil nil nil nil nil nil)
                       ("cco" "import Control.Concurrent\n" "cco" nil nil nil nil nil nil)
                       ("ccstm" "import Control.Concurrent.STM" "ccstm" nil nil nil nil nil nil)
                       ("cd" "import Control.DeepSeq" "cd" nil nil nil nil nil nil)
                       ("cdp" "import Control.Distributed.Process     \n" "cdp" nil nil nil nil nil nil)
                       ("ce" "import Control.Exception" "ce" nil nil nil nil nil nil)
                       ("ch" "import Crypto.Hash" "ch" nil nil nil nil nil nil)
                       ("cl" "import Control.Lens\n" "cl" nil nil
                        ((yas-indent-line 'fixed))
                        nil nil nil)
                       ("class" "class ${1:Name} ${2:a} where\n${3:x} :: ${4:a}" "class" nil nil nil nil nil nil)
                       ("closure" "A closure, the opposite of a combinator, is a function that makes use\nof free variables in its definition. It 'closes' around some portion\nof its environment.for example\nf x = (\\y -> x + y)\nf returns a closure, because the variable x, which is bound outside of the lambda ab\nstraction is used inside its definition. An interesting side note: the\ncontext in which x was bound shouldn't even exist anymore, and\nwouldn't, had \nthe lambda abstraction not closed around x.\n\n\n" "closure" nil nil nil nil nil nil)
                       ("cmb" "import Control.Monad.Base" "cmb" nil nil nil nil nil nil)
                       ("cmc" "import  Control.Monad.CatchIO\n" "cmc" nil nil nil nil nil nil)
                       ("cmdline" "sample :: IO ()\nsample = F.mapM_ print =<< getDoubles\n  where getDoubles = catMaybes . map readMaybe <$> getArgs :: IO [Double]\n" "cmdline" nil nil nil nil nil nil)
                       ("cme" "import Control.Monad.Error\n" "cme" nil nil nil nil nil nil)
                       ("cmf" "import Control.Monad.Fix" "cmf" nil nil nil nil nil nil)
                       ("cmfix" "import Control.Monad.Fix (MonadFix(mfix))\n" "cmfix" nil nil nil nil nil nil)
                       ("cmi" "import Control.Monad.Identity" "cmi" nil nil nil nil nil nil)
                       ("cmmonadio" "import Control.Monad.IO.Class (liftIO)\n" "cmmonadio" nil nil nil nil nil nil)
                       ("cm" "import Control.Monad\n" "Control.Monad" nil nil nil nil nil nil)
                       ("cmp" "import Control.Monad.Plus" "cmp" nil nil nil nil nil nil)
                       ("cmplus" "import Control.Monad (MonadPlus(mzero, mplus))\n" "cmplus" nil nil nil nil nil nil)
                       ("cmr" "import Control.Monad.Reader" "cmr" nil nil nil nil nil nil)
                       ("cms" "import Control.Monad.State" "cms" nil nil nil nil nil nil)
                       ("cmst" "import Control.Monad.ST" "cmst" nil nil nil nil nil nil)
                       ("cmt" "import Control.Monad.Trans" "cmt" nil nil nil nil nil nil)
                       ("cmti" "import Control.Monad.Trans.Identity" "cmti" nil nil nil nil nil nil)
                       ("cmtm" "import Control.Monad.Trans.Maybe" "cmtm" nil nil nil nil nil nil)
                       ("cmtr" "import Control.Monad.Trans.Reader" "cmtr" nil nil nil nil nil nil)
                       ("cmtrans" "import Control.Monad.Trans.Class (MonadTrans(lift))\n" "cmtrans" nil nil nil nil nil nil)
                       ("cmw" "import Control.Monad.Writer\n" "cmw" nil nil nil nil nil nil)
                       ("com" "------------------------------------------------------------------------------\n-- | $1" "com" nil nil nil nil nil nil)
                       ("{-" "{- $0 -}" "block comment" nil nil nil nil nil nil)
                       ("compose" "(.) :: (b -> c) -> (a -> b) -> a -> c\n(.) f g x = f (g x)\n" "compose" nil nil nil nil nil nil)
                       ("concat" "concat :: [[a]] -> [a]\nconcat = foldr (++) []\n" "concat" nil nil nil nil nil nil)
                       ("concatMapM" "concatMapM :: (Monad m) => (a -> m [b]) -> [a] -> m [b]\nconcatMapM f = liftM concat . mapM" "concatMapM" nil nil nil nil nil nil)
                       ("const" "const :: a -> b -> a\nconst x y = x\n\n" "const" nil nil nil nil nil nil)
                       ("=>" "(${1:Class} ${2:m}) => $0" "Type constraint" nil nil nil nil nil nil)
                       ("coolassignment" "x : y : z : _ = [1..]" "coolassignment" nil nil nil nil nil nil)
                       ("cp" "import Control.Parallel\n" "cp" nil nil nil nil nil nil)
                       ("cpp" "{-# LANGUAGE CPP #-}" "cpp" nil nil nil nil nil nil)
                       ("cprox" "import Control.Proxy" "cprox" nil nil nil nil nil nil)
                       ("cps" "import Control.Parallel.Strategies" "cps" nil nil nil nil nil nil)
                       ("crit" "import Criterion" "crit" nil nil nil nil nil nil)
                       ("curry" "curry :: ((a,b) -> c) -> a -> b -> c\ncurry f x y = f (x,y)\n" "curry" nil nil nil nil nil nil)
                       ("cycle" "cycle :: [a] -> [a]\ncycle [] = error \"Cycling on an empty list\"\ncycle xs = xs' where xs' = xs ++ xs'\n" "cycle" nil nil nil nil nil nil)
                       ("d" "deriving ($1)" "d" nil nil nil nil nil nil)
                       ("da" "import Data.Aeson" "da" nil nil nil nil nil nil)
                       ("daa" "import Data.Array.Accelerate as A" "daa" nil nil nil nil nil nil)
                       ("dac" "import Data.Acid" "dac" nil nil nil nil nil nil)
                       ("dai" "import Data.Array.IO" "dai" nil nil nil nil nil nil)
                       ("dal" "import Data.Acid.Local" "dal" nil nil nil nil nil nil)
                       ("dar" "import Data.Acid.Remote" "dar" nil nil nil nil nil nil)
                       ("darr" "import Data.Array" "darr" nil nil nil nil nil nil)
                       ("darrst" "import Data.Array.ST" "darrst" nil nil nil nil nil nil)
                       ("dart" "import Data.Acid.Remote.TLS" "dart" nil nil nil nil nil nil)
                       ("dat" "import Data.Aeson.Types" "dat" nil nil nil nil nil nil)
                       ("data" "data ${1:Type} = ${2:Data}$0 ${3:deriving (${4:Show, Eq})}" "inline data"
                        (=
                         (length "data")
                         (current-column))
                        nil nil nil nil nil)
                       ("data" "data ${1:Type} = $1\n    { ${2:field} :: ${3:Type}\n    , ${4:field} :: ${5:Type}$0\n    } ${6:deriving (${7:Show, Eq})}" "record data"
                        (=
                         (length "data")
                         (current-column))
                        nil nil nil nil nil)
                       ("datto" "import Data.Attoparsec\n\n" "datto" nil nil nil nil nil nil)
                       ("dav" "import Data.Array.Vector" "dav" nil nil nil nil nil nil)
                       ("db" "import qualified Data.Binary as B" "db" nil nil nil nil nil nil)
                       ("db8" "import qualified Data.ByteString.Char8 as B8" "db8" nil nil nil nil nil nil)
                       ("dbc8" "import qualified Data.ByteString.Char8 as B8\n" "dbc8" nil nil nil nil nil nil)
                       ("dbc8" "import qualified Data.ByteString.Char8 as BC\n-- meant to be used for ASCII text" "dbc8" nil nil nil nil nil nil)
                       ("dbi" "import Data.Binary" "dbi" nil nil nil nil nil nil)
                       ("dbits" "import Data.Bits" "dbits" nil nil nil nil nil nil)
                       ("dbl" "import qualified Data.ByteString.Lazy as L" "dbl" nil nil nil nil nil nil)
                       ("dbl8" "import qualified Data.ByteString.Lazy.Char8 as BL8" "dbl8" nil nil nil nil nil nil)
                       ("dblc8" "import qualified Data.ByteString.Lazy.Char8      as L" "dblc8" nil nil nil nil nil nil)
                       ("dblu" "import qualified Data.ByteString.Lazy.UTF8 as LU" "dblu" nil nil nil nil nil nil)
                       ("dbps" "import Database.Persist.Sqlite\n    ( ConnectionPool, SqlPersist, runSqlPool, runMigration\n    , createSqlitePool\n    )" "dbps" nil nil nil nil nil nil)
                       ("dbs" "import qualified Data.ByteString as B\nimport Data.ByteString (ByteString)" "dbs" nil nil nil nil nil nil)
                       ("dbu" "import qualified Data.ByteString.Unsafe              as S" "dbu" nil nil nil nil nil nil)
                       ("dby" "import Data.Byteable" "dby" nil nil nil nil nil nil)
                       ("dc" "import Data.Char" "Data.Char" nil nil nil nil nil nil)
                       ("dcb" "import qualified Data.Conduit.Binary as CB" "dcb" nil nil nil nil nil nil)
                       ("dci" "import Data.CaseInsensitive" "dci" nil nil nil nil nil nil)
                       ("dcl" "import qualified Data.Conduit.List as CL" "dcl" nil nil nil nil nil nil)
                       ("dcon" "import Data.Conduit" "dcon" nil nil nil nil nil nil)
                       ("dconl" "import Data.Conduit.List" "dconl" nil nil nil nil nil nil)
                       ("dd" "import Data.Data" "dd" nil nil nil nil nil nil)
                       ("ddec" "import Data.Decimal" "ddec" nil nil nil nil nil nil)
                       ("ddef" "import Data.Default" "ddef" nil nil nil nil nil nil)
                       ("ddeq" "import qualified Data.Dequeue as DQ" "ddeq" nil nil nil nil nil nil)
                       ("ddt" "{-# LANGUAGE DeriveDataTypeable   #-}\n" "ddt" nil nil nil nil nil nil)
                       ("de" "import qualified Data.Enumerator as I" "de" nil nil nil nil nil nil)
                       ("deb" "import Data.Enumerator.Binary" "deb" nil nil nil nil nil nil)
                       ("debug" "import           Debug.Trace (traceShow)" "debug" nil nil nil nil nil nil)
                       ("dei" "import Data.Either" "dei" nil nil nil nil nil nil)
                       ("del" "# -*- mode: snippet -*-\n# name: del\n# key: del\n# author: dmj\n# -- \nimport Data.Enumerator.List" "del" nil nil nil nil nil nil)
                       ("del.yasnippet" "" "del.yasnippet" nil nil nil nil nil nil)
                       ("delay" "delay :: Int -> IO ()\ndelay = let secs = (*1000000) in threadDelay . secs\n" "delay" nil nil nil nil nil nil)
                       ("derg" "{-# LANGUAGE DeriveGeneric  #-}\n" "derg" nil nil nil nil nil nil)
                       ("df" "import Data.Foldable ${1:(Foldable(foldMap))}\n" "df" nil nil nil nil nil nil)
                       ("dfun" "import Data.Functor" "dfun" nil nil nil nil nil nil)
                       ("dfunc" "import Data.Function" "dfunc" nil nil nil nil nil nil)
                       ("dg" "import Data.Graph" "dg" nil nil nil nil nil nil)
                       ("dge" "{-# LANGUAGE DeriveGeneric #-}" "dge" nil nil nil nil nil nil)
                       ("dgen" "import Data.Generic" "dgen" nil nil nil nil nil nil)
                       ("dgth" "import Database.Groundhog.TH" "dgth" nil nil nil nil nil nil)
                       ("dh" "import Data.Hashable" "dh" nil nil nil nil nil nil)
                       ("dhs" "import qualified Data.HashMap.Strict  as H\n" "dhs" nil nil nil nil nil nil)
                       ("di" "import Data.IORef" "di" nil nil nil nil nil nil)
                       ("die" "import Data.Either" "die" nil nil nil nil nil nil)
                       ("dist" "import           Distribution.Simple\n\nmain :: IO ()\nmain = defaultMain\n" "dist" nil nil nil nil nil nil)
                       ("dix" "import Data.Ix\n" "dix" nil nil nil nil nil nil)
                       ("dl" "import Data.List\n" "dl" nil nil nil nil nil nil)
                       ("dl" "import Data.List\n" "dl" nil nil nil nil nil nil)
                       ("dls" "import Data.List.Split" "dls" nil nil nil nil nil nil)
                       ("dm" "import Data.Monoid" "dm" nil nil nil nil nil nil)
                       ("dmap" "import qualified Data.Map as M" "dmap" nil nil nil nil nil nil)
                       ("dmay" "import Data.Maybe" "dmay" nil nil nil nil nil nil)
                       ("dms" "import qualified Data.Map.Strict as M" "dms" nil nil nil nil nil nil)
                       ("do" "import Data.Ord" "do" nil nil nil nil nil nil)
                       ("dotrans" "--do e → e\n--do { e; stmts } → e >> do { stmts }\n--do { v <- e; stmts } → e >>= \\v -> do { stmts }\n--do { let decls; stmts} → let decls in do { stmts }\n" "dotrans" nil nil nil nil nil nil)
                       ("drop" "drop :: Int -> [a] -> [a]\ndrop n xs    | n <= 0 = xs\ndrop _ []    = []\ndrop n (_:xs) = drop (n-1) xs\n" "drop" nil nil nil nil nil nil)
                       ("dropWhile" "dropWhile :: (a -> Bool) -> [a] -> [a]\ndropWhile _ [] = []\ndropWhile f xs@(x:xs')\n    | f x          = dropWhile f xs'\n    | otherwise    = xs\n" "dropWhile" nil nil nil nil nil nil)
                       ("ds" "import Data.Semigroup\n" "ds" nil nil nil nil nil nil)
                       ("dsa" "import Data.SafeCopy" "dsa" nil nil nil nil nil nil)
                       ("dsc" "$(deriveSafeCopy 0 'base ''$1)" "dsc" nil nil nil nil nil nil)
                       ("dsci" "import Data.Scientific" "dsci" nil nil nil nil nil nil)
                       ("dse" "import Data.Serialize" "dse" nil nil nil nil nil nil)
                       ("dseq" "import Data.Sequence" "dseq" nil nil nil nil nil nil)
                       ("dset" "import Data.Set" "dset" nil nil nil nil nil nil)
                       ("dstr" "import Data.String" "dstr" nil nil nil nil nil nil)
                       ("dt" "import qualified Data.Text as T\nimport           Data.Text    (Text)" "dt" nil nil nil nil nil nil)
                       ("dtc" "import Data.Time.Clock (diffUTCTime, getCurrentTime)" "dtc" nil nil nil nil nil nil)
                       ("dtcp" "import           Data.Time.Clock.POSIX\n" "dtcp" nil nil nil nil nil nil)
                       ("dte" "import qualified Data.Text.Encoding as T" "dte" nil nil nil nil nil nil)
                       ("dtf" "import           Data.Time.Format" "dtf" nil nil nil nil nil nil)
                       ("dti" "import Data.Time" "dti" nil nil nil nil nil nil)
                       ("dtime" "import Data.Time" "dtime" nil nil nil nil nil nil)
                       ("dtio" "import qualified Data.Text.IO as T" "dtio" nil nil nil nil nil nil)
                       ("dtl" "import qualified Data.Text.Lazy as LT" "dtl" nil nil nil nil nil nil)
                       ("dtle" "import qualified Data.Text.Lazy.Encoding as T" "dtle" nil nil nil nil nil nil)
                       ("dtrav" "import Data.Traversable ${1:(Traversable(traverse))}\n" "dtrav" nil nil nil nil nil nil)
                       ("dtree" "import Data.Tree" "dtree" nil nil nil nil nil nil)
                       ("dtup" "import Data.Tuple" "dtup" nil nil nil nil nil nil)
                       ("dtyp" "import Data.Typeable\n" "dtyp" nil nil nil nil nil nil)
                       ("du" "import Data.Unique" "du" nil nil nil nil nil nil)
                       ("dual" "newtype Dual a = Dual { getDual :: a } \n	deriving (Show, Eq, Ord, Bounded, Read)\n" "dual" nil nil nil nil nil nil)
                       ("dv" "import Data.Vector" "dv" nil nil nil nil nil nil)
                       ("dver" "import Data.Version as DV" "dver" nil nil nil nil nil nil)
                       ("dw" "import Data.Word\n" "dw" nil nil nil nil nil nil)
                       ("dynamic" "import           Data.Dynamic\n\nhlist :: [Dynamic]\nhlist = [ toDyn \"string\"\n        , toDyn (7 :: Int)\n        , toDyn (pi :: Double)\n        , toDyn 'x'\n        , toDyn ((), Just \"foo\")\n        ]\n\ndyn :: Dynamic\ndyn = hlist !! 1\n\nv :: Int\nv = case fromDynamic dyn of\n         Nothing -> error \"Type mismatch\"\n         Just x -> x\n\nmain :: IO ()\nmain = do putStrLn $ show v\n" "dynamic" nil nil nil nil nil nil)
                       ("edd" "{-# LANGUAGE EmptyDataDecls            #-}\n" "edd" nil nil nil nil nil nil)
                       ("eee" "Another instance of Functor that we've been dealing with all along but didn't know was a Functor is (->) r. You're probably slightly confused now, since what the heck does (->) r mean? The function type r -> a can be rewritten as (->) r a, much like we can write 2 + 3 as (+) 2 3. When we look at it as (->) r a, we can see (->) in a slighty different light, because we see that it's just a type constructor that takes two type parameters, just like Either. But remember, we said that a type constructor has to take exactly one type parameter so that it can be made an instance of Functor. That's why we can't make (->) an instance of Functor, but if we partially apply it to (->) r, it doesn't pose any problems. If the syntax allowed for type constructors to be partially applied with sections (like we can partially apply + by doing (2+), which is the same as (+) 2), you could write (->) r as (r ->). How are functions functors? Well, let's take a look at the implementation, which lies in Control.Monad.Instances" "eee" nil nil nil nil nil nil)
                       ("either" "data Either a b = Left a | Right b " "either" nil nil nil nil nil nil)
                       ("elem" "elem :: Eq a => a -> [a] -> Bool\nelem _ [] = False\nelem y xs = any (==y) xs\n" "elem" nil nil nil nil nil nil)
                       ("encode" "import           Data.Binary\n\nencodeStuff = do\n  encodeFile \"cookie.txt\" (4 :: Int)\n\ndecodeStuff = do\n  int <- decodeFile \"cookie.txt\" :: IO Int\n  return int\n\nmain = do\n  encodeStuff\n  num <- decodeStuff\n  print num\n" "encode" nil nil nil nil nil nil)
                       ("endomonoid" "instance Monoid (Endo a) where\n    mempty = Endo id\n    mappend (Endo f) (Endo g) = Endo (f . g)\n" "endomonoid" nil nil nil nil nil nil)
                       ("enumerator" "{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main where\n\nimport           Control.Concurrent     (threadDelay)\nimport           Control.Monad.IO.Class (MonadIO (liftIO))\nimport qualified Data.ByteString        as BS\nimport qualified Data.ByteString.Char8  as BS8\nimport           Data.Enumerator\nimport           Data.Enumerator.Binary as EB\nimport           Data.Enumerator.List   as EL\nimport           Data.Maybe\nimport           Data.Word8\nimport           System.IO\n\n-- ByteString -> Maybe (IO Word8)\nconsumer :: Iteratee BS.ByteString IO ()\nconsumer = do\n  mw <- EB.head\n  case mw of\n    Nothing -> return ()\n    Just w  -> do\n             liftIO . putStr $ \"XXX \"\n             liftIO . BS8.putStrLn . BS.singleton $ w\n             liftIO $ threadDelay $ 1000000 `div` 2\n             consumer\n\nlistFeeder :: Enumerator BS.ByteString IO a\nlistFeeder = enumList 1 [\"12\", \"34\"]\n\nfileFeeder :: Enumerator BS.ByteString IO a\nfileFeeder = EB.enumFile \"filef\"\n\nconsumer2 :: Iteratee BS.ByteString IO ()\nconsumer2 = do\n  mw <- EB.head\n  case mw of\n    Nothing -> return ()\n    Just x -> do\n              liftIO . putStr $ \"YYY \"\n              liftIO . BS8.putStrLn . BS.singleton $ x\n              consumer2\n\n-- run_ $ (fileFeeder <==< listFeeder) $$ consumer\n\nenumHandleLines :: MonadIO m => Integer -> Handle ->\n                   Enumerator BS.ByteString m BS.ByteString\nenumHandleLines n hdl = EB.enumHandle n hdl $= byteLines\n\nbyteLines :: Monad m =>\n             Enumeratee BS.ByteString BS.ByteString m b\nbyteLines = EB.splitWhen (== 10) -- 10 is LF\n" "enumerator" nil nil nil nil nil nil)
                       ("eq" "{-# LANGUAGE ExistentialQuantification #-}\n" "eq" nil nil nil nil nil nil)
                       ("f" "${1:name} :: ${2:a} -> ${3:b}\n$1 = " "f" nil nil nil nil nil nil)
                       ("fac" "fac :: Integer -> Integer\nfac 0 = 1\nfac n = n * fac (n - 1)\n" "fac" nil nil nil nil nil nil)
                       ("fastserver" "{-# LANGUAGE OverloadedStrings #-}\n\n-- brew install httperf\n-- httperf --server=localhost --port=5002 --uri=/ --num-conns=10000\n\nimport           Control.Concurrent\nimport           Data.ByteString.Char8\nimport qualified Data.ByteString.Char8     as BC\nimport           Network                   hiding (accept)\nimport           Network.Socket\nimport           Network.Socket.ByteString (sendAll)\nimport           System.IO\n\nmain = withSocketsDo $ do\n         sock <- listenOn $ PortNumber 5002\n         loop sock\n\nloop sock = do\n  (conn, _) <- accept sock\n  forkIO $ body conn\n  loop sock\n      where\n        body c = do sendAll c msg\n                    sClose c\n\nmsg = \"HTTP/1.0 200 OK\\r\\nContent-Length: 5\\r\\n\\r\\nPong!\\r\\n\"\n" "fastserver" nil nil nil nil nil nil)
                       ("fc" "{-# LANGUAGE FlexibleContexts #-}" "fc" nil nil nil nil nil nil)
                       ("fct" "import Foreign.C.Types" "fct" nil nil nil nil nil nil)
                       ("fd" "{-# LANGUAGE FunctionalDependencies #-}" "fd" nil nil nil nil nil nil)
                       ("ffi" "{-# LANGUAGE ForeignFunctionInterface  #-}\n" "ffi" nil nil nil nil nil nil)
                       ("ffitest" "{-# LANGUAGE ForeignFunctionInterface #-}\n\nimport           Control.Monad\nimport           Foreign.C.Types\n\nforeign import ccall unsafe \"stdlib.h rand\"\n     c_rand :: IO CUInt\n\nforeign import ccall unsafe \"stdlib.h getchar\"\n     getc :: IO CUChar\n\n\nmain :: IO ()\nmain = do a <- getc\n          print a\n\n" "ffitest" nil nil nil nil nil nil)
                       ("fi" "{-# LANGUAGE FlexibleInstances #-}" "fi" nil nil nil nil nil nil)
                       ("fib" "fib@(1:tfib) = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ]\n" "fib" nil nil nil nil nil nil)
                       ("fib2" "fib2 = unfoldr (\\n -> Just (numerator n, 1/(1+n))) 0" "fib2" nil nil nil nil nil nil)
                       ("filter" "filter :: (a -> Bool) -> [a] -> [a]\nfilter _ [] = []\nfilter p (x:xs)\n    | p x       = x : filter p xs\n    | otherwise = filter p xs\n" "filter" nil nil nil nil nil nil)
                       ("filterM" "filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]\nfilterM _ [] = return []\nfilterM f (x:xs) = do\n  flag <- f x\n  ys <- filterM f xs\n  return (if flag then x:ys else ys)" "filterM" nil nil nil nil nil nil)
                       ("findUniq" "findUniq :: Ord a => [a] -> [a]\nfindUniq xs = map fst $ toList $ go xs empty\n  where go [] m     = m\n        go (x:xs) m = go xs (insert x True m)\n" "findUniq" nil nil nil nil nil nil)
                       ("fix" "fix :: (a -> a) -> a\nfix f = f (fix f)\n\n" "fix" nil nil nil nil nil nil)
                       ("fk" "forkIO" "fk" nil nil nil nil nil nil)
                       ("flaskport" "if __name__ == '__main__':\n    port = int(os.environ.get(\"PORT\", 5000))\n    app.run(host='0.0.0.0', port=port)\n\n" "flaskport" nil nil nil nil nil nil)
                       ("flip" "flip :: (a -> b -> c) -> b -> a -> c\nflip f x y = f y x\n" "flip" nil nil nil nil nil nil)
                       ("flipapp" "(<**>) :: Applicative f => f a -> f (a -> b) -> f b\n(<**>) = liftA2 (flip ($))" "flipapp" nil nil nil nil nil nil)
                       ("fn" "${1:f} :: ${2:a} ${3:-> ${4:b}}\n$1 ${5:x} = ${6:expression}$0" "simple function"
                        (=
                         (length "fn")
                         (current-column))
                        nil
                        ((yas-indent-line 'fixed))
                        nil nil nil)
                       ("fn" "${1:f} :: ${2:a} ${3:-> ${4:b}}\n$1 ${5:pattern} = ${7:expression}\n$1 ${6:pattern} = ${8:expression}$0" "clause function"
                        (=
                         (length "fn")
                         (current-column))
                        nil
                        ((yas-indent-line 'fixed))
                        nil nil nil)
                       ("fn" "${1:f} :: ${2:a} ${3:-> ${4:b}}\n$1 ${5:x}\n    | ${6:conditional} = ${8:expression}\n    | ${7:conditional} = ${9:expression}$0" "guarded function"
                        (=
                         (length "fn")
                         (current-column))
                        nil
                        ((yas-indent-line 'fixed))
                        nil nil nil)
                       ("fo" "import Foreign" "fo" nil nil nil nil nil nil)
                       ("foldM" "foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a\nfoldM f a []     = return a\nfoldM f a (x:xs) = f a x >>= \\fax -> foldM f fax xs\n" "foldM" nil nil nil nil nil nil)
                       ("foldM_" "foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()\nfoldM_ f a (xs) = foldM f a xs >> return ()" "foldM_" nil nil nil nil nil nil)
                       ("foldableidentityt" "instance (Foldable f) => Foldable (IdentityT f) where\n    foldMap f (IdentityT a) = foldMap f a" "foldableidentityt" nil nil nil nil nil nil)
                       ("foldablet" "instance (Foldable f) => Foldable (${1:Type}T f) where\n    foldMap f ($1T a) = $2\n    " "foldablet" nil nil nil nil nil nil)
                       ("foldabletree" "instance F.Foldable Tree where\n    foldMap _ Empty = mempty\n    foldMap f (Node x l r) = F.foldMap f l `mappend`\n                             f x `mappend`\n                             F.foldMap f r\n" "foldabletree" nil nil nil nil nil nil)
                       ("foldl'" "foldl' :: (a -> b -> a) -> a -> [b] -> a\nfoldl' f x xs = go x xs\n  where go z [] = z\n        go z (y:ys) = let x' = f z y in x' `seq` go x' ys\n" "foldl'" nil nil nil nil nil nil)
                       ("foldll" "foldl' :: (a -> b -> a) -> a -> [b] -> a\nfoldl' f z []     = z\nfoldl' f z (x:xs) = seq z $ foldl' f (f z x) xs\n" "foldll" nil nil nil nil nil nil)
                       ("foldl" "foldl :: (a -> b -> a) -> a -> [b] -> a\nfoldl f x xs = go x xs \n      where\n         go z [] = z\n         go z (y:ys) = go (f z y) ys\n\n" "foldl" nil nil nil nil nil nil)
                       ("foldr" "foldr :: (a -> b -> b) -> b -> [a] -> b\nfoldr _ y [] = y\nfoldr f y (x:xs) = f x (foldr f y xs)" "foldr" nil nil nil nil nil nil)
                       ("for" "for :: (Monad m) => m a -> m Bool -> m b -> m c -> m ()\nfor init cond post action = do\n  init\n  while cond $ do\n    action\n    post\n" "for" nil nil nil nil nil nil)
                       ("forM" "forM :: Monad m => [a] -> (a -> m b) -> m [b]\nforM = flip mapM\n" "forM" nil nil nil nil nil nil)
                       ("foreign" "import Foreign" "foreign" nil nil nil nil nil nil)
                       ("forever" "forever :: Monad m => m a -> m b\nforever a = let a' = a in a' >> forever a'\n" "forever" nil nil nil nil nil nil)
                       ("fp" "import Foreign.Ptr" "fp" nil nil nil nil nil nil)
                       ("freemonad" "data Free f a = Pure a | Free (f (Free f a))\n\ninstance Functor f => Functor (Free f) where\n   fmap f (Pure a) = Pure (f a)\n   fmap f (Free as) = Free (fmap (fmap f) as)\n\ninstance Functor f => Monad (Free f) where\n   return = Pure\n   Pure a >>= f = f a -- the first monad law!\n   Free as >>= f = Free (fmap (>>= f) as)\n" "freemonad" nil nil nil nil nil nil)
                       ("fromJust" "fromJust          :: Maybe a -> a\nfromJust Nothing  = error \"Maybe.fromJust: Nothing\" -- yuck\nfromJust (Just x) = x" "fromJust" nil nil nil nil nil nil)
                       ("fromMaybe" "-- | The 'fromMaybe' function takes a default value and and 'Maybe'\n-- value.  If the 'Maybe' is 'Nothing', it returns the default values;\n-- otherwise, it returns the value contained in the 'Maybe'.\nfromMaybe     :: a -> Maybe a -> a\nfromMaybe d x = case x of {Nothing -> d;Just v  -> v}\n" "fromMaybe" nil nil nil nil nil nil)
                       ("fromjson" "instance FromJSON $1 where\n   parseJSON (Object o) = $2  " "fromjson" nil nil nil nil nil nil)
                       ("fst" "fst :: (a,b) -> a\nfst (x,_) = x\n" "fst" nil nil nil nil nil nil)
                       ("ft" "${1:name} :: ${2:Class} => ${3:a} -> ${4:b}\n$1 = " "ft" nil nil nil nil nil nil)
                       ("functor" "class Functor f where\n	fmap :: (a -> b) -> f a -> f b\n	(<$) :: a -> f b -> f a\n	(<$) = fmap . const\n" "functor" nil nil nil nil nil nil)
                       ("functore" "instance Functor ((->) e) where\n   fmap = (.)" "functore" nil nil nil nil nil nil)
                       ("functoridentity" "instance Functor Identity where\n    fmap f m = Identity (f (runIdentity m))" "functoridentity" nil nil nil nil nil nil)
                       ("functoridentityt" "instance Functor m => Functor (IdentityT m) where\n    fmap f = mapIdentityT (fmap f)" "functoridentityt" nil nil nil nil nil nil)
                       ("functorlaws" "-- fmap id  ==  id\n-- fmap (f . g)  ==  fmap f . fmap g" "functorlaws" nil nil nil nil nil nil)
                       ("functorlist" "instance Functor [] where\n    fmap _ []     = []\n    fmap f (x:xs) = f x : fmap f xs" "functorlist" nil nil nil nil nil nil)
                       ("functormaybe" "instance Functor Maybe where\n    fmap _ Nothing    = Nothing\n    fmap f (Just x)   = Just (f x)" "functormaybe" nil nil nil nil nil nil)
                       ("functort" "instance (Functor m) => Functor (${1:Type}T m) where\n    fmap f $2 = $3\n    " "functort" nil nil nil nil nil nil)
                       ("functorziplist" "instance Functor ZipList where\n   fmap f (ZipList xs) = ZipList $ map f xs" "functorziplist" nil nil nil nil nil nil)
                       ("yfn" "import Yesod.Form.Nic (YesodNic, nicHtmlField)" "yfn" nil nil nil nil nil nil)
                       ("gadts" "{-# LANGUAGE GADTs #-}" "gadts" nil nil nil nil nil nil)
                       ("gc" "import GHC.Conc" "gc" nil nil nil nil nil nil)
                       ("<-" "${1:x} <- ${2:expression}$0" "monadic get" nil nil nil nil nil nil)
                       ("getParam" "${1:param} <- getParam \"${2:name}\"" "getParam" nil nil nil nil nil nil)
                       ("getRandoms" "getRandoms :: RandomList :: (Random a, RandomGen b) => b -> [a]\ngetRandoms = unfoldr (Just . random)\n" "getRandoms" nil nil nil nil nil nil)
                       ("gft" "import GHC.Fingerprint.Type" "gft" nil nil nil nil nil nil)
                       ("gg" "import GHC.Generics\n" "gg" nil nil nil nil nil nil)
                       ("gi" "import GHC.Int" "gi" nil nil nil nil nil nil)
                       ("gnd" "{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n" "gnd" nil nil nil nil nil nil)
                       ("gntd" "{-# LANGUAGE GeneralizedNewtypeDeriving #-}" "gntd" nil nil nil nil nil nil)
                       ("goldbach" "-- Every even integer greater than 2 can be expressed as the sum of two primes." "goldbach" nil nil nil nil nil nil)
                       ("gp" "import GHC.Prim" "gp" nil nil nil nil nil nil)
                       ("group" "-- a group is a set of elements together with an operation that combines\n-- any two of its elements to form a third element also in the set\n-- while satisfying four conditions called the group axioms, namely\n-- closure, associativity, identity and invertibility. One of the most\n-- familiar examples of a group is the set of integers together with\n-- the addition operation; the addition of any two integers forms\n-- another integer. The abstract formalization of the group axioms,\n-- detached as it is from the concrete nature of any particular group\n-- and its operation, allows entities with highly diverse mathematical\n-- origins in abstract algebra and beyond to be handled in a flexible\n-- way, while retaining their essential structural aspects. The\n-- ubiquity of groups in numerous areas within and outside mathematics\n-- makes them a central organizing principle of contemporary mathematics" "group" nil nil nil nil nil nil)
                       ("gs" "import GHC.Stats" "gs" nil nil nil nil nil nil)
                       ("guard" "guard :: MonadPlus m => Bool -> m ()\nguard True = return ()\nguard False = mzero\n" "guard" nil nil nil nil nil nil)
                       ("guessinggame" "import           System.Random\n\nmain :: IO ()\nmain = do\n  gen <- getStdGen\n  let nums = take 100 $ randomRs (1,10) gen :: [Int]\n  putStrLn \"Welcome to Guess the Number, guess a number 1-10 (only get 10 chances)\"\n  loop nums\n  putStrLn \"Would you like to play again? (y/n)\"\n  c <- getLine\n  case c of\n    \"y\" -> main\n    _ -> putStrLn \"goodbye\"\n\nloop :: [Int] -> IO ()\nloop [] = putStrLn \"You Lose!!!!\"\nloop (x:xs) = do\n  guess <- fmap read getLine\n  case compare (guess :: Int) x of\n    LT -> putStrLn \"Too low!\" >> loop xs\n    GT -> putStrLn \"Too high!\" >> loop xs\n    _  -> putStrLn \"You win!\"\n" "guessinggame" nil nil nil nil nil nil)
                       ("gzip" "import           Codec.Compression.GZip" "gzip" nil nil nil nil nil nil)
                       ("h" "$1 :: Handler App (AuthManager App) ()\n$1 = method $2 handle$2\n  where handle$2 = currentUser >>= maybe the404 handleUser\n        handleUser AuthUser{..} = do\n           $3\n" "h" nil nil nil nil nil nil)
                       ("ham" "[hamlet| $1 |]" "ham" nil nil nil nil nil nil)
                       ("hand" "$1 :: Handler App (AuthManager App) ()\n$1 = $2" "hand" nil nil nil nil nil nil)
                       ("happshello" "import qualified Data.ByteString.Lazy as BL\n\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main where\n\nimport           Happstack.Server\nimport           Data.Text (Text)\n\n\nmain :: IO ()\nmain = simpleHTTP nullConf $ ok (\"{\\\"hello\\\": \\\"world\\\"}\" :: Text)" "happshello" nil nil nil nil nil nil)
                       ("head" "head :: [a] -> a\nhead (x:_) = x\nhead [] = error \"Prelude.empty head\"\n" "head" nil nil nil nil nil nil)
                       ("hi" "import Heist.Interpreted" "hi" nil nil nil nil nil nil)
                       ("hnf" "<dolio> \\x -> (\\y -> (y,x)) 3\n<dolio> Is in weak head normal form, but not head normal form.\n" "hnf" nil nil nil nil nil nil)
                       ("hoog" ":def search return . (\":! hoogle \" ++)" "hoog" nil nil nil nil nil nil)
                       ("hspec" "import Test.Hspec" "hspec" nil nil nil nil nil nil)
                       ("html5bp" "layout :: Html -> Html -> Html\nlayout t b = docTypeHtml $ do\n           pet \"<!--[if lt IE 7]>      <html class='no-js lt-ie9 lt-ie8 lt-ie7'> <![endif]-->\"\n           pet \"<!--[if IE 7]>         <html class='no-js lt-ie9 lt-ie8'/> <![endif]-->\"\n           pet \"<!--[if IE 8]>         <html class='no-js lt-ie9'> <![endif]-->\"\n           pet \"<!--[if gt IE 8]><!--> <html class='no-js'> <!--<![endif]-->\"\n           head $ do\n             title t\n             meta ! charset \"utf-8\"\n             meta ! httpEquiv \"X-UA-Compatible\" ! content \"IE=edge,chrome=1\"\n             meta ! name \"description\" ! content \"\"\n             meta ! name \"viewport\" ! content \"width=device-width\"\n             link ! href \"//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css\"\n                  ! rel  \"stylesheet\" ! media \"screen\"\n           body $ do\n             b\n             script ! src \"//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js\" $ mempty\n             script ! src \"//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js\" $ mempty\n" "html5bp" nil nil nil nil nil nil)
                       ("i" "import" "i" nil nil nil nil nil nil)
                       ("icom" "-- *" "icom" nil nil nil nil nil nil)
                       ("idb" "import Data.Bool" "idb" nil nil nil nil nil nil)
                       ("idempotency" "Applying a function once has the same effect as applying it twice" "idempotency" nil nil nil nil nil nil)
                       ("identity" "newtype Identity a = Identity { runIdentity :: a }\n" "identity" nil nil nil nil nil nil)
                       ("identityt" "newtype IdentityT m a = IdentityT { runIdentityT :: m a }\n" "identityt" nil nil nil nil nil nil)
                       ("idxs" "idxs :: (Eq a, Num b, Enum b) => [a] -> a -> [b]\nidxs word br = [i | (i, c) <- zip [0..] word,  c == br]\n" "idxs" nil nil nil nil nil nil)
                       ("if" "if ${1:condition}\n    then ${2:expression}\n    else ${3:expression}$0" "block if" nil nil nil nil nil nil)
                       ("if" "if ${1:condition} then ${2:expression} else ${3:expression}$0" "inline if" nil nil nil nil nil nil)
                       ("ih" "instance HasHeist ${1:App} where\n	heistLens = subSnaplet heist" "ih" nil nil nil nil nil nil)
                       ("iicom" "---- * $1" "iicom" nil nil nil nil nil nil)
                       ("im" "import qualified Data.IntMap.Strict as I" "im" nil nil nil nil nil nil)
                       ("imp" "import           ${1:Module} ${2:(${3:f})}" "simple import"
                        (=
                         (length "imp")
                         (current-column))
                        nil nil nil nil nil)
                       ("imp" "import qualified ${1:Module} as ${2:${1:$(let ((name (car (last (split-string yas-text \"\\\\\\.\")))))\n                                              (if (not (nil-blank-string name)) \"\"\n                                                  (subseq name 0 1)))}}$0" "qualified import"
                        (=
                         (length "imp")
                         (current-column))
                        nil nil nil nil nil)
                       ("in" "instance " "in" nil nil nil nil nil nil)
                       ("init" "init :: [a] -> [a]\ninit [] = error \"empty list\"\ninit (x:xs) = init' x xs where\n    init' _ []     = xs\n    init' x (y:ys) = x : init' y ys\n" "init" nil nil nil nil nil nil)
                       ("inline" "{-# INLINE ${1:function} #-}" "inline" nil nil nil nil nil nil)
                       ("insertionSort" "insert :: Ord a => a -> [a] -> [a]\ninsert x [] = [x]\ninsert x (y:xs)\n       | x <= y    = x : y : xs\n       | otherwise = y : insert x xs\n\ninsertSort :: Ord a => [a] -> [a]\ninsertSort = foldr insert []" "insertionSort" nil nil nil nil nil nil)
                       ("inst" "instance ${1:Class} ${2:Data} where\n    ${3:f} = ${4:expression}$0" "instance"
                        (=
                         (length "inst")
                         (current-column))
                        nil nil nil nil nil)
                       ("insterror" "instance Error Person where\n    noMsg = Person \"uhoh\" 0\n    strMsg s = Person s 1\n" "insterror" nil nil nil nil nil nil)
                       ("intercalate" "intercalate :: [a] -> [[a]] -> [a]\nintercalate xs xss = concat (intersperse xs xss)" "intercalate" nil nil nil nil nil nil)
                       ("intersperse" "intersperse             :: a -> [a] -> [a]\nintersperse _   []      = []\nintersperse sep (x:xs)  = x : prependToAll sep xs" "intersperse" nil nil nil nil nil nil)
                       ("intersperse" "intersperse :: a -> [a] -> [a]\nintersperse _ [] = []\nintersperse x (y:ys) =  y : x : intersperse x ys\n" "intersperse" nil nil nil nil nil nil)
                       ("ioref" "main = do varA <- newIORef 0  -- Create and initialize a new variable\n          a0 <- readIORef varA\n          writeIORef varA 1\n          a1 <- readIORef varA\n          print (a0, a1)\n" "ioref" nil nil nil nil nil nil)
                       ("iq" "import qualified $1 as $2" "iq" nil nil nil nil nil nil)
                       ("is" "import Snap" "is" nil nil nil nil nil nil)
                       ("isJust" "isJust :: Maybe a -> Bool\nisJust Nothing  = False\nisJust _        = True\n" "isJust" nil nil nil nil nil nil)
                       ("isNothing" "isNothing :: Maybe a -> Bool\nisNothing Nothing  = True\nisNothing _        = False\n" "isNothing" nil nil nil nil nil nil)
                       ("ip" "isPrime :: Integer -> Bool\nisPrime n = null $ filter ((==0) . (mod n)) $\n            takeWhile ((<=n) . (^2)) [2..]\n" "ip" nil nil nil nil nil nil)
                       ("iteratee" "consumer :: Iteratee BS.ByteString IO ()\nconsumer = do\n    mw <- EB.head\n    case mw of\n        Nothing -> return ()\n        Just w  -> do\n            liftIO . putStr $ \"XXX \"\n            liftIO . BS.putStrLn . BS.singleton $ w\n            consumer" "iteratee" nil nil nil nil nil nil)
                       ("ix" "class Ord a => Ix a where\n    range :: (a,a) -> [a]\n    index :: (a,a) -> a -> Int\n    inRange :: (a,a) -> a -> Bool\n" "ix" nil nil nil nil nil nil)
                       ("iy" "import Yesod" "iy" nil nil nil nil nil nil)
                       ("iya" "import Yesod.Auth" "iya" nil nil nil nil nil nil)
                       ("iyfj" "import Yesod.Form.Jquery" "iyfj" nil nil nil nil nil nil)
                       ("join" "join :: Monad m => m (m a) -> m a\njoin ma = ma >>= id\n" "join" nil nil nil nil nil nil)
                       ("jul" "[julius| $1 |]" "jul" nil nil nil nil nil nil)
                       ("kleislicat" "instance Monad m => Category (Kleisli m) where\n    id = Kleisli return\n    Kleisli g . Kleisli h = Kleisli (h >=> g)\n" "kleislicat" nil nil nil nil nil nil)
                       ("knapsack" "import           Data.Array\n\n-- http://en.wikipedia.org/wiki/Knapsack_problem\n\nknapsack01 :: [Double]   -- values\n           -> [Integer]  -- nonnegative weights\n           -> Integer    -- knapsack size\n           -> Double     -- max possible value\nknapsack01 vs ws maxW = m!(numItems-1, maxW)\n  where numItems = length vs\n        m = array ((-1,0), (numItems-1, maxW)) $\n              [((-1,w), 0) | w <- [0 .. maxW]] ++\n              [((i,0), 0) | i <- [0 .. numItems-1]] ++\n              [((i,w), best)\n                  | i <- [0 .. numItems-1]\n                  , w <- [1 .. maxW]\n                  , let best\n                          | ws!!i > w  = m!(i-1, w)\n                          | otherwise = max (m!(i-1, w))\n                                            (m!(i-1, w - ws!!i) + vs!!i)\n              ]\n\nexample = knapsack01 [3,4,5,8,10] [2,3,4,5,9] 20\n" "knapsack" nil nil nil nil nil nil)
                       ("ks" "--These two combinators form a complete basis for the entire lambda\n--calculus. Every lambda calculus program can be written using just\n--these two functions.\nk :: a -> b -> a\nk = \\x y -> x\n\ns :: (a -> b -> c) -> (a -> b) -> a -> c\ns = \\x y z -> x z (y z)\n\n" "ks" nil nil nil nil nil nil)
                       ("\\" "\\\\${1:x} -> ${2:expression}$0" "lambda" nil nil nil nil nil nil)
                       ("lang" "{-# LANGUAGE `(progn (require 'haskell-yas) (haskell-yas-complete \"Extension: \" haskell-yas-ghc-language-pragmas))` #-}" "language pragma"
                        (=
                         (length "lang")
                         (current-column))
                        nil nil nil nil nil)
                       ("lapp" "(<*) :: Applicative f => f a -> f b -> f a\n(<*) = liftA2 const\n" "lapp" nil nil nil nil nil nil)
                       ("last" "last :: [a] -> a\nlast [] = error \"empty list\"\nlast [x] = x\nlast (x:xs) = last xs\n" "last" nil nil nil nil nil nil)
                       ("lattice" "class Eq a => Lattice a where\n    bottom, top :: a\n    meet, join :: a -> a -> a\n    lt         :: a -> a -> Bool\n    x `lt` y   = (x `join` y) == y" "lattice" nil nil nil nil nil nil)
                       ("lazyio" "{-# LANGUAGE OverloadedStrings   #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n\nimport           Control.Concurrent (threadDelay)\nimport           Control.Monad\nimport           System.IO\n\ndelay :: Int -> IO ()\ndelay = let secs = (*1000000) in threadDelay . secs\n\nmain :: IO ()\nmain = do\n  putStrLn \"Closing the file handle prematurely, big no no\"\n  delay 2\n  replicateM_ 100 wrong\n  putStrLn \"As you can see nothing got printed\"\n  delay 2\n  putStrLn \"Second no-no don't close the file handle at all!\"\n  replicateM_ 1000 stillWrong\n\n--wrong: closes before reads, nothing gets printed\nwrong :: IO ()\nwrong = withFile \"cool.txt\" ReadMode hGetContents  >>= putStr\n\n--wrong: doesn't close file handle at all!\nstillWrong :: IO ()\nstillWrong = do\n  handle <- openFile \"cool.txt\" ReadMode\n  str <- fmap head $ hGetContents handle\n  putChar str\n\n--correct: reads the file entirely into ram, prints it, closes it\nright :: IO ()\nright =\n  withFile \"cool.txt\" ReadMode $ \\handle -> do\n          fileData <- fmap head $ hGetContents handle\n          putChar fileData\n\n--better, uses an iteratee to \"stream\" (read incrementally in steps)\n--data from disk to in chunks\n" "lazyio" nil nil nil nil nil nil)
                       ("lazytostrict" "lazyToStrict = B.concat $ BL.toChunks lazy" "lazytostrict" nil nil nil nil nil nil)
                       ("lc" "{-# LANGUAGE LambdaCase #-}" "lc" nil nil nil nil nil nil)
                       ("length" "-- length = sum . map (+1)\nlength :: [a] -> Int\nlength xs    = len 0 xs where\n    len num [] = num\n    len num (_:xs) = len (num + 1) xs\n" "length" nil nil nil nil nil nil)
                       ("let" "let ${1:x} = ${2:expression}$0" "let" nil nil nil nil nil nil)
                       ("lhth" "import           Language.Haskell.TH" "lhth" nil nil nil nil nil nil)
                       ("lift2IdentityT" "-- | Lift a binary operation to the new monad.\nlift2IdentityT :: (m a -> n b -> p c) -> IdentityT m a -> IdentityT n b -> IdentityT p c\nlift2IdentityT f a b = IdentityT (f (runIdentityT a) (runIdentityT b))\n" "lift2IdentityT" nil nil nil nil nil nil)
                       ("liftM" "liftM :: Monad m => (a -> b) -> m a -> m b\nliftM f ma = ma >>= return . f\n" "liftM" nil nil nil nil nil nil)
                       ("liftM2" "liftM2 :: Monad m => (a -> b -> c) -> m a -> m b -> m c\nliftM2 f ma mb = do\n  a <- ma\n  b <- mb\n  return $ f a b\n  " "liftM2" nil nil nil nil nil nil)
                       ("liftM3" "liftM3  :: (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r\nliftM3 f m1 m2 m3       = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }\n" "liftM3" nil nil nil nil nil nil)
                       ("lifta" "liftA :: Applicative f => (a -> b) -> f a -> f b\nliftA f a = pure f <*> a -- or (<$>)" "lifta" nil nil nil nil nil nil)
                       ("lifta2" "liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c\nliftA2 f x y = f <$ > x <*> y\n" "lifta2" nil nil nil nil nil nil)
                       ("liftlaws" "lift . return   =  return\nlift (m >>= f)  =  lift m >>= (lift . f)" "liftlaws" nil nil nil nil nil nil)
                       ("lio" "io = liftIO" "lio" nil nil nil nil nil nil)
                       ("listToMaybe" "listToMaybe :: [a] -> Maybe a\nlistToMaybe [] = Nothing\nlistToMaybe (x:_) = Just x\n" "listToMaybe" nil nil nil nil nil nil)
                       ("listt" "newtype ListT t m a = ListT { runListT :: m [a] }" "listt" nil nil nil nil nil nil)
                       ("lmap" "(<$) :: Functor f => a -> f b -> f a\n(<$) = fmap . const\n" "lmap" nil nil nil nil nil nil)
                       ("lookup" "lookup :: Eq a => a -> [(a,b)] -> Maybe b\nlookup x [] = Nothing\nlookup x ((y,z):xs)\n    | x == y    = Just z\n    | otherwise = lookup x xs\n\n" "lookup" nil nil nil nil nil nil)
                       ("lth" "import Language.Haskell.TH" "lth" nil nil nil nil nil nil)
                       ("lua.cf" "chunk ::= {stat [`;´]} [laststat [`;´]]\n\n	block ::= chunk\n\n	stat ::=  varlist `=´ explist | \n		 functioncall | \n		 do block end | \n		 while exp do block end | \n		 repeat block until exp | \n		 if exp then block {elseif exp then block} [else block] end | \n		 for Name `=´ exp `,´ exp [`,´ exp] do block end | \n		 for namelist in explist do block end | \n		 function funcname funcbody | \n		 local function Name funcbody | \n		 local namelist [`=´ explist] \n\n	laststat ::= return [explist] | break\n\n	funcname ::= Name {`.´ Name} [`:´ Name]\n\n	varlist ::= var {`,´ var}\n\n	var ::=  Name | prefixexp `[´ exp `]´ | prefixexp `.´ Name \n\n	namelist ::= Name {`,´ Name}\n\n	explist ::= {exp `,´} exp\n\n	exp ::=  nil | false | true | Number | String | `...´ | function | \n		 prefixexp | tableconstructor | exp binop exp | unop exp \n\n	prefixexp ::= var | functioncall | `(´ exp `)´\n\n	functioncall ::=  prefixexp args | prefixexp `:´ Name args \n\n	args ::=  `(´ [explist] `)´ | tableconstructor | String \n\n	function ::= function funcbody\n\n	funcbody ::= `(´ [parlist] `)´ block end\n\n	parlist ::= namelist [`,´ `...´] | `...´\n\n	tableconstructor ::= `{´ [fieldlist] `}´\n\n	fieldlist ::= field {fieldsep field} [fieldsep]\n\n	field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | exp\n\n	fieldsep ::= `,´ | `;´\n\n	binop ::= `+´ | `-´ | `*´ | `/´ | `^´ | `%´ | `..´ | \n		 `<´ | `<=´ | `>´ | `>=´ | `==´ | `~=´ | \n		 and | or\n\n	unop ::= `-´ | not | `#´\n" "lua.cf" nil nil nil nil nil nil)
                       ("luc" "[lucius| $1 |]" "luc" nil nil nil nil nil nil)
                       ("m" "module" "m" nil nil nil nil nil nil)
                       ("main" "main :: IO ()\nmain = " "main module" nil nil nil nil nil nil)
                       ("mainsnap" "main = quickHttpServe $ writeText \"hello world\"" "mainsnap" nil nil nil nil nil nil)
                       ("map" "map :: (a -> b) -> [a] -> [b]\nmap _ [] = []\nmap f (x:xs) = f x : map f xs\n" "map" nil nil nil nil nil nil)
                       ("mapAndUnzipM" "mapAndUnzipM :: Monad m => (a -> m (b,c)) -> [a] -> m ([b], [c])\nmapAndUnzipM f xs = sequence (map f xs) >>= return . unzip\n  " "mapAndUnzipM" nil nil nil nil nil nil)
                       ("mapIdentityT" "-- | Lift a unary operation to the new monad.\nmapIdentityT :: (m a -> n b) -> IdentityT m a -> IdentityT n b\nmapIdentityT f = IdentityT . f . runIdentityT" "mapIdentityT" nil nil nil nil nil nil)
                       ("mapM" "mapM :: Monad m => (a -> m b) -> [a] -> m [b]\nmapM _ []     = return []\nmapM f (x:xs) = do\n  y <- f x\n  ys <- mapM f xs\n  return $ y:ys\n" "mapM" nil nil nil nil nil nil)
                       ("mapM_ " "mapM_           :: Monad m => (a -> m b) -> [a] -> m ()\nmapM_ f as      =  sequence_ (map f as)\n" "mapM_ " nil nil nil nil nil nil)
                       ("mapMaybe" "mapMaybe          :: (a -> Maybe b) -> [a] -> [b]\nmapMaybe _ []     = []\nmapMaybe f (x:xs) =\n let rs = mapMaybe f xs in\n case f x of\n  Nothing -> rs\n  Just r  -> r:rs" "mapMaybe" nil nil nil nil nil nil)
                       ("mappend" "infixr 6 (<>)\n(<>) :: (Monoid a) => a -> a -> a\n(<>) = mappend\n" "mappend" nil nil nil nil nil nil)
                       ("maybe" "data Maybe a = Nothing | Just a " "maybe" nil nil nil nil nil nil)
                       ("mayb" "maybe :: b -> (a -> b) -> Maybe a -> b\nmaybe x _ Nothing = x\nmaybe _ f (Just y) = f y\n" "mayb" nil nil nil nil nil nil)
                       ("maybeToList" "maybeToList :: Maybe a -> [a]\nmaybeToList Nothing = []\nmaybeToList (Just x) = [x]\n" "maybeToList" nil nil nil nil nil nil)
                       ("maybet" "newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }\n" "maybet" nil nil nil nil nil nil)
                       ("maybetexample" "import Control.Monad\nimport Control.Monad.Trans\n\nnewtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }\n\ninstance Monad m => Monad (MaybeT m) where\n    return = MaybeT . return . Just\n    x >>= f = MaybeT $ do maybe_val <- runMaybeT x\n                          case maybe_val of\n                            Nothing -> return Nothing\n                            Just x -> runMaybeT $ f x\n\ninstance Monad m => MonadPlus (MaybeT m) where\n    mzero = MaybeT $ return Nothing\n    mplus x y = MaybeT $ do maybe_val <- runMaybeT x\n                            case maybe_val of\n                              Nothing -> runMaybeT y\n                              Just _ -> return maybe_val\n\ninstance MonadTrans MaybeT where\n    lift = MaybeT . (liftM Just)\n\ngetValidPassword :: MaybeT IO String\ngetValidPassword = do s <- lift getLine\n                      guard (isValid s)\n                      return s\n\naskPassword' :: MaybeT IO ()\naskPassword' = do lift $ putStrLn \"Insert your new password\"\n                  value <- getValidPassword\n                  lift $ putStrLn \"Storing in db...\"\n\nmain :: IO ()\nmain = do\n  runMaybeT askPassword'\n  runMaybeT getValidPassword\n  putStrLn \"done\"" "maybetexample" nil nil nil nil nil nil)
                       ("mean" "mean :: Fractional a => [a] -> a\nmean xs = s / fromIntegral l where\n    (s,l) = foldl' step (0,0) xs\n    step (!s,!l) a = (s + a, l + 1)\n" "mean" nil nil nil nil nil nil)
                       ("mergesort" "mergeSort :: Ord a => [a] -> [a]\nmergeSort []    = []\nmergeSort [x]   = [x]\nmergeSort xs    = merge (mergeSort x1) (mergeSort x2)\n  where (x1,x2) = splitAt (div (length xs) 2) xs\n\nmerge :: Ord a => [a] -> [a] -> [a]\nmerge [] x = x\nmerge x [] = x\nmerge (x:xs) (y:ys) \n    | x < y     = x : merge xs (y:ys)\n    | otherwise = y : merge (x:xs) ys" "mergesort" nil nil nil nil nil nil)
                       ("mfilter" "mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a\nmfilter p m = do\n  a <- m\n  if p a then return a else mzero\n  " "mfilter" nil nil nil nil nil nil)
                       ("mfix" "class Monad m => MonadFix m where\n    mfix :: (a -> m a) -> m a\n" "mfix" nil nil nil nil nil nil)
                       ("mfixt" "instance (MonadFix m) => MonadFix (${1:Type}T m) where\n    mfix f = $1T $2\n    " "mfixt" nil nil nil nil nil nil)
                       ("migration" "instance Migrate $1 where\n     type MigrateFrom $1 = $2\n     migrate ($2)" "migration" nil nil nil nil nil nil)
                       ("mka" "$(makeAcidic' ''$1 ['$2])" "mka" nil nil nil nil nil nil)
                       ("mkl" "$(makeLenses ''${1:Name})" "mkl" nil nil nil nil nil nil)
                       ("mm" "module Main where\n" "mm" nil nil nil nil nil nil)
                       ("mmv" "modifyMVar_" "mmv" nil nil nil nil nil nil)
                       ("mmw" "module Main where" "mmw" nil nil nil nil nil nil)
                       ("modcom" "-- |\n-- Module      : $1\n-- Description : $2\n-- Copyright   : (c) David Johnson, 2014\n-- License     : $3\n-- Maintainer  : djohnson.m@gmail.com\n-- Stability   : experimental\n-- Portability : POSIX\n--\n-- @some markup@.\n" "modcom" nil nil nil nil nil nil)
                       ("mhs" "modifyHeistState" "mhs" nil nil nil nil nil nil)
                       ("mod" "module ${1:`(if (not buffer-file-name) \"Module\"\n                (let ((name (file-name-sans-extension (buffer-file-name))))\n                     (if (search \"src/\" name)\n                         (replace-regexp-in-string \"/\" \".\" (car (last (split-string name \"src/\"))))\n                         (file-name-nondirectory name))))`} where\n\n$0" "simple module"
                        (=
                         (length "mod")
                         (current-column))
                        nil
                        ((yas-indent-line 'fixed))
                        nil nil nil)
                       ("mod" "module ${1:`(if (not buffer-file-name) \"Module\"\n                (let ((name (file-name-sans-extension (buffer-file-name))))\n                     (if (search \"src/\" name)\n                         (replace-regexp-in-string \"/\" \".\" (car (last (split-string name \"src/\"))))\n                         (file-name-nondirectory name))))`}\n    ( ${3:export}\n    ${4:, ${5:export}}\n    ) where\n\n$0" "exports module"
                        (=
                         (length "mod")
                         (current-column))
                        nil
                        ((yas-indent-line 'fixed))
                        nil nil nil)
                       ("monad" "class Monad m where\n	return :: a -> m a\n	(>>=)  :: m a -> (a -> m b) -> m b\n	(>>)   :: m a -> m b -> m b\n	m >> n = m >>= \\_ -> n\n" "monad" nil nil nil nil nil nil)
                       ("monadfixidentity" "instance MonadFix Identity where\n    mfix f = Identity (fix (runIdentity . f))\n    " "monadfixidentity" nil nil nil nil nil nil)
                       ("monadfixidentityt" "instance (MonadFix m) => MonadFix (IdentityT m) where\n    mfix f = IdentityT (mfix (runIdentityT . f))\n    " "monadfixidentityt" nil nil nil nil nil nil)
                       ("monadfixlaws" "-- purity\n   -- mfix (return . h) = return (fix h)\n\n--left shrinking (or tightening)\n   -- mfix (\\x -> a >>= \\y -> f x y) = a >>= \\y -> mfix (\\x -> f x y)\n\n-- sliding\n   -- mfix (liftM h . f) = liftM h (mfix (f . h)), for strict h.\n\n-- nesting\n   -- mfix (\\x -> mfix (\\y -> f x y)) = mfix (\\x -> f x x)\n" "monadfixlaws" nil nil nil nil nil nil)
                       ("monadidentity" "instance Monad Identity where\n    return a = Identity a\n    m >>= k  = k (runIdentity m)" "monadidentity" nil nil nil nil nil nil)
                       ("monadidentityt" "instance (Monad m) => Monad (IdentityT m) where\n    return = IdentityT . return\n    m >>= k = IdentityT $ runIdentityT . k =<< runIdentityT m\n    fail msg = IdentityT $ fail msg\n    " "monadidentityt" nil nil nil nil nil nil)
                       ("monadio" "class (Monad m) => MonadIO m where\n   liftIO :: IO a -> m a" "monadio" nil nil nil nil nil nil)
                       ("monadiot" "instance (MonadIO m) => MonadIO (${1:Type}T m) where\n    liftIO = $1T $2\n    " "monadiot" nil nil nil nil nil nil)
                       ("monadlaws" "	# -*- mode: snippet -*-\n	# key: monadlaws\n	# name: monadlaws\n	# contributor: David Johnson\n	# --\n--Left Identity: return a >>= f == f a	\n--Right Identity: m >>= return == m\n--Associativity: (m >>= f) >>= g == m >>= (\\x -> f x >>= g)\n--or\n--Associativity: (m >=> f) >=> g == m >=> (f >=> g)\n\n-- In Kleisli terms\n--return >=> g  =  g\n--g >=> return  =  g\n--(g >=> h) >=> k  =  g >=> (h >=> k)\n--As fans of category theory will note, these laws say precisely that functions of type \n--a -> m b are the arrows of a category with (>=>) as composition! Indeed, this is known as\n--the Kleisli category of the monad m." "monadlaws" nil nil nil nil nil nil)
                       ("monadlist" "instance  Monad []  where\n    m >>= k             = foldr ((++) . k) [] m\n    m >> k              = foldr ((++) . (\\ _ -> k)) [] m\n    return x            = [x]\n    fail _              = []" "monadlist" nil nil nil nil nil nil)
                       ("monadlistt" "instance (Monad m) => Monad (ListT m) where\n    return x = ListT . return $ [x]\n    m >>= f = ListT $ do vals <- runListT m\n                         xs <- mapM (runListT . f) vals\n                         return (concat xs)\n" "monadlistt" nil nil nil nil nil nil)
                       ("monadmaybe" "instance Monad Maybe where\n    return = Just\n    Nothing >>= _ = Nothing\n    Just x >>= f = f x" "monadmaybe" nil nil nil nil nil nil)
                       ("monadmaybet" "instance Monad m => Monad (MaybeT m) where\n    return = MaybeT . return . Just\n    m >>= f = MaybeT $ do maybe_value <- runMaybeT m\n                          case maybe_value of\n                            Nothing -> return Nothing\n                            Just x -> runMaybeT $ f x" "monadmaybet" nil nil nil nil nil nil)
                       ("monadplus" "class Monad m => MonadPlus m where\n    mzero :: m a\n    mplus :: m a -> m a -> m a" "monadplus" nil nil nil nil nil nil)
                       ("monadplusidentityt" "instance (MonadPlus m) => MonadPlus (IdentityT m) where\n    mzero = IdentityT mzero\n    mplus = lift2IdentityT mplus\n    " "monadplusidentityt" nil nil nil nil nil nil)
                       ("monadpluslist" "instance MonadPlus [] where\n	mzero = []\n	mappend = (++)\n	" "monadpluslist" nil nil nil nil nil nil)
                       ("monadplust" "instance (MonadPlus m) => MonadPlus (${1:Class}T m) where\n    mzero = $1T mzero\n    mplus = $2\n    " "monadplust" nil nil nil nil nil nil)
                       ("monadreader" "class Monad m => MonadReader r m | m -> r where\n    -- | retrieves monadic environment\n    ask :: m r\n    -- | retrieves computation in a modified environment\n    local :: (r -> r) -- execs function in a modified environment\n             -> m a -- reader to run in modified environment\n             -> m a\n    -- | retrieves a function of the current environment\n    reader :: (r -> a) -> m a -- selector function to apply to the environment\n    reader f = do\n      r <- ask\n      return (f r)\n\nasks :: MonadReader r m => (r -> a) -> m a -- applies (r -> a) to environment\nasks = reader\n" "monadreader" nil nil nil nil nil nil)
                       ("monadstate" "class MonadState m s | m -> s where\n    get :: m s\n    put :: s -> m ()\n" "monadstate" nil nil nil nil nil nil)
                       ("monadt" "instance (Monad m) => Monad (${1:Type}T m) where\n    return = $1T $2\n    m >>= k = $1T $ $3\n    fail msg = $1T $ fail msg\n    " "monadt" nil nil nil nil nil nil)
                       ("monadtrans" "class MonadTrans t where\n    lift :: (Monad m) => m a -> t m a" "monadtrans" nil nil nil nil nil nil)
                       ("monadtransidentityt" "instance MonadTrans IdentityT where\n    lift = IdentityT\n    " "monadtransidentityt" nil nil nil nil nil nil)
                       ("monadtransmaybet" "instance MonadTrans MaybeT where\n    lift m = MaybeT (m >>= return . Just)" "monadtransmaybet" nil nil nil nil nil nil)
                       ("monadtranst" "instance MonadTrans ${1:Type}T where\n    lift = $1T\n    " "monadtranst" nil nil nil nil nil nil)
                       ("monadwriter" "class (Monoid w, Monad m) => MonadWriter w m | m -> w where\n    -- | @'writer' (a,w)@ embeds a simple writer action.\n    writer :: (a,w) -> m a\n    writer ~(a, w) = do\n      tell w\n      return a\n\n    -- | @'tell' w@ is an action that produces the output @w@.\n    tell   :: w -> m ()\n    tell w = writer ((),w)\n\n    -- | @'listen' m@ is an action that executes the action @m@ and adds\n    -- its output to the value of the computation.\n    listen :: m a -> m (a, w)\n    -- | @'pass' m@ is an action that executes the action @m@, which\n    -- returns a value and a function, and returns the value, applying\n    -- the function to the output.\n    pass   :: m (a, w -> w) -> m a" "monadwriter" nil nil nil nil nil nil)
                       ("monoid" "class Monoid m where\n	mempty :: m\n	mappend :: m -> m -> m\n	mconcat :: [m] -> m		\n	mconcat = foldr mappend mempty" "monoid" nil nil nil nil nil nil)
                       ("monoidal" "class Functor f => Monoidal f where\n    unit :: f ()\n    (**) :: f a -> f b -> f (a,b)" "monoidal" nil nil nil nil nil nil)
                       ("monoidallaws" "\n-- Naturality (here: g *** h == \\(x,y) -> (g x, h y))\n-- fmap (g *** h) (u ** v) = fmap g u ** fmap h v\n\n-- Left Identity\n-- unit ** v ≅ v\n-- In this and the following laws, ≅ refers to isomorphism rather than equality. In particular we consider (x,()) ≅ x ≅ ((),x) and ((x,y),z) ≅ (x,(y,z)).\n\n-- Right Identity\n-- u ** unit ≅ u\n\n-- Associativity\n-- u ** (v ** w) ≅ (u ** v) ** w\n\n-- All of the above laws are equivalent to the applicative laws\n-- Identity, Homomorphism, Interchangeability, Composition\n\n\n\n\n\n\n" "monoidallaws" nil nil nil nil nil nil)
                       ("monoidlaws" "--a <> (b <> c) = (a <> b) <> c\n--mempty <> a = a\n--a <> mempty = a\n" "monoidlaws" nil nil nil nil nil nil)
                       ("monoidlist" "instance Monoid [a] where\n	mempty = []\n	mappend = (++)\n" "monoidlist" nil nil nil nil nil nil)
                       ("monoidmaybe" "instance Monoid a => Monoid (Maybe a) where\n    mempty = Nothing\n    Nothing `mappend` _ = Nothing\n    _ `mappend` Nothing = Nothing\n    Just x `mappend` Just y = Just (x `mappend` y)\n" "monoidmaybe" nil nil nil nil nil nil)
                       ("monoidord" "instance Monoid Ordering where\n	mempty = EQ\n	LT `mappend` _   = LT\n	EQ `mappend` _ y = y\n	GT `mappend` _   = GT\n" "monoidord" nil nil nil nil nil nil)
                       ("monoidtuple" "instance Monoid ((,) a) where\n	mempty = (,)\n	a `mappend` b = (a,b)\n" "monoidtuple" nil nil nil nil nil nil)
                       ("mptc" "{-# LANGUAGE MultiParamTypeClasses #-}" "mptc" nil nil nil nil nil nil)
                       ("ms" "makeSnaplet " "ms" nil nil nil nil nil nil)
                       ("msum" "msum :: MonadPlus m => [m a] -> m a\nmsum = foldr mplus mzero" "msum" nil nil nil nil nil nil)
                       ("nc" "import Network.Connection" "nc" nil nil nil nil nil nil)
                       ("nemv" "newEmptyMVar" "nemv" nil nil nil nil nil nil)
                       ("nestSnaplet" "${1:var} <- nestSnaplet \"${2:name}\" ${3:instance} $ $3Init \"${4:location}\"" "nestSnaplet" nil nil nil nil nil nil)
                       ("net" "import Network\n" "net" nil nil nil nil nil nil)
                       ("neth" "import           Network.HTTP" "neth" nil nil nil nil nil nil)
                       ("netu" "import           Network.URI" "netu" nil nil nil nil nil nil)
                       ("new" "newtype ${1:Type} = $1 { un$1 :: ${2:a} } ${3:deriving (${4:Show, Eq})}" "newtype"
                        (=
                         (length "new")
                         (current-column))
                        nil nil nil nil nil)
                       ("nhc" "import Network.Http.Client" "nhc" nil nil nil nil nil nil)
                       ("nmv" "newMVar" "nmv" nil nil nil nil nil nil)
                       ("nobuff" "hSetBuffering stdout NoBuffering\n" "nobuff" nil nil nil nil nil nil)
                       ("normalform" "-- An expression in normal form is fully evaluated, \n-- and no sub-expression could be evaluated any \n-- further (i.e. it contains no un-evaluated thunks).\n" "normalform" nil nil nil nil nil nil)
                       ("not" "not :: Bool -> Bool\nnot True  = False\nnot False = True\n" "not" nil nil nil nil nil nil)
                       ("notElem" "notElem :: Eq a => a -> [a] -> Bool\nnotElem x = all (/=x)\n" "notElem" nil nil nil nil nil nil)
                       ("np" "newPtr" "np" nil nil nil nil nil nil)
                       ("ns" "import Network.Socket\n" "ns" nil nil nil nil nil nil)
                       ("nsbs" "import Network.Socket.ByteString\n" "nsbs" nil nil nil nil nil nil)
                       ("nsh" "${1:name} <- nestSnaplet \"heist\" heist $ heistInit \"templates\"\n" "nsh" nil nil nil nil nil nil)
                       ("nu" "import Network.URL" "nu" nil nil nil nil nil nil)
                       ("null" "null :: [a] -> Bool\nnull []     = True\nnull (_:_)  = False\n" "null" nil nil nil nil nil nil)
                       ("num" "import Numeric" "num" nil nil nil nil nil nil)
                       ("nw" "import Network.Wai" "nw" nil nil nil nil nil nil)
                       ("nwhw" "import Network.Wai.Handler.WarpTLS" "nwhw" nil nil nil nil nil nil)
                       ("nwmr" "import Network.Wai.Middleware.RequestLogger" "nwmr" nil nil nil nil nil nil)
                       ("nwms" "import Network.Wai.Middleware.Static" "nwms" nil nil nil nil nil nil)
                       ("nws" "import qualified Network.WebSockets as WS       \nimport qualified Network.WebSockets.Snap as WS       " "nws" nil nil nil nil nil nil)
                       ("o" "otherwise" "o" nil nil nil nil nil nil)
                       ("oi" "{-# LANGUAGE OverlappingInstances #-}\n" "oi" nil nil nil nil nil nil)
                       ("or" "or :: [Bool] -> Bool -- foldr (||) False\nor [] = False\nor (x:xs) = x || (or xs)\n" "or" nil nil nil nil nil nil)
                       ("orphans" "{-# OPTIONS_GHC -fno-warn-orphans #-}\n" "orphans" nil nil nil nil nil nil)
                       ("os" "{-# LANGUAGE OverloadedStrings #-}" "os" nil nil nil nil nil nil)
                       ("pairaa" "data Pair a = Pair a a " "pairaa" nil nil nil nil nil nil)
                       ("parallelismvsconcurrency" "There's a fine distinction between concurrency and parallelism:\n# parallelism is all about making your program run faster by making\n# use of multiple processors simultaneously. Concurrency, on the other\n# hand, is a means of abstraction: it is a convenient way to structure\n# a program that must respond to multiple asynchronous events." "parallelismvsconcurrency" nil nil nil nil nil nil)
                       ("person" "data Person = Person\n    { name :: String\n    , age  :: Int\n    } deriving (Show, Eq)\n    " "person" nil nil nil nil nil nil)
                       ("pg" "{-# LANGUAGE PatternGuards #-}\n" "pg" nil nil nil nil nil nil)
                       ("pi" "{-# LANGUAGE PackageImports       #-}\n" "pi" nil nil nil nil nil nil)
                       ("pmv" "putMVar $1 $2" "pmv" nil nil nil nil nil nil)
                       ("pr" "import Prelude hiding ($1)" "pr" nil nil nil nil nil nil)
                       ("prependToAll" "prependToAll            :: a -> [a] -> [a]\nprependToAll _   []     = []\nprependToAll sep (x:xs) = sep : x : prependToAll sep xs" "prependToAll" nil nil nil nil nil nil)
                       ("prime" "isPrime :: Int -> Bool\nisPrime n = null $ filter ((==0) . (mod n)) $\n            takeWhile ((<=n) . (2^)) [2..]" "prime" nil nil nil nil nil nil)
                       ("product" "product :: Num a => [a] -> a\nproduct (xs) = go 1 xs where\n    go acc [] = acc\n    go acc (x:xs) = go (acc * x) xs\n" "product" nil nil nil nil nil nil)
                       ("ps" "putStrLn \"$1\"" "ps" nil nil nil nil nil nil)
                       ("put" "put :: s -> State s ()\nput x = State $ \\s -> ((),x)\n" "put" nil nil nil nil nil nil)
                       ("q" "qualified" "q" nil nil nil nil nil nil)
                       ("qc" "quickCheck" "qc" nil nil nil nil nil nil)
                       ("qhs" "quickHttpServe $1" "qhs" nil nil nil nil nil nil)
                       ("qq" "{-# LANGUAGE QuasiQuotes #-}" "qq" nil nil nil nil nil nil)
                       ("qs" "qs :: Ord a => [a] -> [a]\nqs [] = []\nqs (x:xs) = qs left ++ [x] ++ qs right where\n    left  = filter (<x) xs\n    right = filter (>=x) xs\n    " "qs" nil nil nil nil nil nil)
                       ("qsvector" "module QS where\n\nimport           Control.Concurrent (threadDelay)\nimport           Data.Vector\nimport           Prelude            hiding (filter, head, init, null,\ntail,\n                                     (++))\nimport           System.Random\n\n-- * fast quicksort\nqs :: Ord a => Vector a -> Vector a\nqs x | null x = empty\nqs xs = qs left ++ singleton x ++ qs right\n  where left  = filter (<x) $ tail xs\n        right = filter (>=x) $ tail xs\n        x = head xs\n\nmain :: IO ()\nmain = do\n  gen <- getStdGen\n  let xs = randomRs (1,10000000) gen :: [Integer]\n  let nums = fromList $ Prelude.take 100000 xs\n  putStrLn \"Loaded vector into memory...\"\n  threadDelay 100000000\n  print $ qs nums" "qsvector" nil nil nil nil nil nil)
                       ("query" "$1 :: Query DB $2\n$1 = do\n   db <- ask\n   $3\n" "query" nil nil nil nil nil nil)
                       ("r" "return ()" "r" nil nil nil nil nil nil)
                       ("r2t" "{-# LANGUAGE Rank2Types                #-}\n" "r2t" nil nil nil nil nil nil)
                       ("rando" "main = do\n  gen <- getStdGen\n  let num = randomR (1,1000) gen :: (Int, StdGen)\n  putStrLn $ show $ fst num" "rando" nil nil nil nil nil nil)
                       ("rapp" "(*>) :: Applicative f => f a -> f b -> f b\n(*>) = liftA2 (const id)\n" "rapp" nil nil nil nil nil nil)
                       ("re" "return" "re" nil nil nil nil nil nil)
                       ("reader" "newtype Reader r a = Reader { runReader :: r -> a }" "reader" nil nil nil nil nil nil)
                       ("redirect" "redirect ${1:url}" "redirect" nil nil nil nil nil nil)
                       ("render" "render \"${1:handler}\"" "render" nil nil nil nil nil nil)
                       ("repeat" "repeat :: a -> [a]\nrepeat x = xs where xs = x : repeat x\n" "repeat" nil nil nil nil nil nil)
                       ("replicate" "replicate :: Int -> a -> [a]\nreplicate n x = take n $ repeat x\n" "replicate" nil nil nil nil nil nil)
                       ("reverse" "reverse :: [a] -> [a]\nreverse = foldl (flip (:)) []\n" "reverse" nil nil nil nil nil nil)
                       ("rnt" "{-# LANGUAGE RankNTypes #-}" "rnt" nil nil nil nil nil nil)
                       ("rot13" "rot13 :: String -> String\nrot13 = iterate rotate >>> (!!13)\n    where rotate = map rot\n          rot c | c == 'z' = 'a'\n                | otherwise = succ c\n\n" "rot13" nil nil nil nil nil nil)
                       ("rp" "readPtr" "rp" nil nil nil nil nil nil)
                       ("rs" "(${1:Text}, site, ${2:IO}) <- runSnaplet ${3:Maybe String} ${4:init}\n" "rs" nil nil nil nil nil nil)
                       ("rtv" "readTVar" "rtv" nil nil nil nil nil nil)
                       ("rwc" "{-# LANGUAGE RecordWildCards #-}" "rwc" nil nil nil nil nil nil)
                       ("rws" "import Control.Monad.RWS" "rws" nil nil nil nil nil nil)
                       ("rwst" "import Control.Monad.RWS" "rwst" nil nil nil nil nil nil)
                       ("sad" "{-# LANGUAGE StandaloneDeriving      #-}" "sad" nil nil nil nil nil nil)
                       ("sc" "import System.Cmd" "sc" nil nil nil nil nil nil)
                       ("sca" "import System.Console.ANSI" "sca" nil nil nil nil nil nil)
                       ("scanl" "scanl :: (a -> b -> a) -> a -> [b] -> [a]\nscanl f q ls = q : (case ls of\n                       []   -> []\n                       x:xs -> scanl f (f q x) xs)\n" "scanl" nil nil nil nil nil nil)
                       ("scanl1" "scanl1 :: (a -> a -> a) -> [a] -> [a]\nscanl1 p (x:xs) = scanl p x xs\nscanl1 p _ = []\n" "scanl1" nil nil nil nil nil nil)
                       ("scanr" "scanr :: (a -> b -> b) -> b -> [a] -> [b]\nscanr _ b []     = [b]\nscanr f x (y:ys) = f y q : qs\n    where qs@(q:_) = scanr f x ys\n" "scanr" nil nil nil nil nil nil)
                       ("scanr1" "scanr1 :: (a -> a -> a) -> [a] -> [a]\nscanr1 _ [] = []\nscanr1 _ [x] = [x]\nscanr1 p (x:xs) = scanr p x xs\n" "scanr1" nil nil nil nil nil nil)
                       ("scc" "import System.Console.CmdArgs" "scc" nil nil nil nil nil nil)
                       ("sco" "{-# SCC \"$1\" #-}$2" "sco" nil nil nil nil nil nil)
                       ("sd" "serveDirectory \"${1:static}\"" "sd" nil nil nil nil nil nil)
                       ("sdr" "import System.Directory" "sdr" nil nil nil nil nil nil)
                       ("se" "import System.Environment\n" "se" nil nil nil nil nil nil)
                       ("second" "second f = arr f <<< first swap <<< arr f\n  where swap ~(x,y) = (x,y)" "second" nil nil nil nil nil nil)
                       ("secs" "secs :: Int -> Int\nsecs = (*1000000)" "secs" nil nil nil nil nil nil)
                       ("selectionSort" "selectSort :: (Ord a) ⇒ [a] → [a]\nselectSort = unfoldr select\n\nselect :: (Ord a) ⇒ [a] → Maybe (a, [a])\nselect [] = Nothing\nselect (x : xs) =\n    case select xs of\n      Nothing → Just (x, [ ])\n      Just (y, ys)\n          | x <= y → Just (x, xs)\n          | otherwise → Just (y, x : ys)\n" "selectionSort" nil nil nil nil nil nil)
                       ("seminearring" "class (Monoid a) => Seminearring a where\n  one :: a\n  (*) :: a -> a -> a\n" "seminearring" nil nil nil nil nil nil)
                       ("sequence" "sequence :: Monad m => [m a] -> m [a]\nsequence xs = foldr k (return []) xs where\n	k ma mb = do\n		a <- ma\n		b <- mb\n		return (a:b)\n		" "sequence" nil nil nil nil nil nil)
                       ("sequence_" "sequence_  =  foldr (>>) (return ())\n" "sequence_" nil nil nil nil nil nil)
                       ("set" "type Size = Int\ndata Set a = Tip\n           | Bin {-# UNPACK #-} !Size a !(Set a) !(Set a)\n" "set" nil nil nil nil nil nil)
                       ("sexit" "import System.Exit" "sexit" nil nil nil nil nil nil)
                       ("sf" "import System.FilePath" "sf" nil nil nil nil nil nil)
                       ("sfp" "import System.FilePath" "sfp" nil nil nil nil nil nil)
                       ("sft" "import System.File.Tree" "sft" nil nil nil nil nil nil)
                       ("shs" "import Snap.Http.Server" "shs" nil nil nil nil nil nil)
                       ("si" "import System.IO" "si" nil nil nil nil nil nil)
                       ("sie" "import System.IO.Error" "sie" nil nil nil nil nil nil)
                       ("sieve" "primes = sieve [2..]\n    where sieve (p:xs) = \n      p : sieve [x | x <- xs, x `mod` p /= 0]\n" "sieve" nil nil nil nil nil nil)
                       ("sio" "import System.IO.Error  " "sio" nil nil nil nil nil nil)
                       ("sios" "import           System.IO.Streams (InputStream, OutputStream)\nimport qualified System.IO.Streams as Streams" "sios" nil nil nil nil nil nil)
                       ("sisp" "import System.IO.Streams.Process" "sisp" nil nil nil nil nil nil)
                       ("siu" "import System.IO.Unsafe" "siu" nil nil nil nil nil nil)
                       ("sl" "import System.Locale" "sl" nil nil nil nil nil nil)
                       ("sls" "import Snap.Loader.Static" "sls" nil nil nil nil nil nil)
                       ("smile" "¯\\_(ツ)_/¯" "smile" nil nil nil nil nil nil)
                       ("sn" "import Snap\n" "sn" nil nil nil nil nil nil)
                       ("snaph" "${1:handler} :: Handler ${2:App} $2 ()\n$1 = $3\n" "snaph" nil nil nil nil nil nil)
                       ("snapi" "${1:init} :: SnapletInit ${2:App} $2\n$1 = makeSnaplet \"${3:name}\" \"${4:description}\" Nothing $ do\n	addRoutes [(\"\", ${5:handler})]\n	return $ $2 { }\n" "snapi" nil nil nil nil nil nil)
                       ("snapp" "data ${1:App} = $1 {	\n   _heist :: Snaplet (Heist $1)\n}\n" "snapp" nil nil nil nil nil nil)
                       ("snh" "import Snap.Snaplet.Heist\n" "snh" nil nil nil nil nil nil)
                       ("so" "import System.IO\n" "so" nil nil nil nil nil nil)
                       ("sp" "import System.Posix\n" "sp" nil nil nil nil nil nil)
                       ("span" "-- | span' :: (a -> Bool) -> [a] -> ([a],[a])\n-- | span' p xs = (dropWhile p xs, takeWhile p xs)\n\nspan :: (a -> Bool) -> [a] -> ([a],[a])\nspan p xs@[] = ([],[])\nspan p xs@(x:xs')\n    | p x       = let (ys, zs) = span p xs' in (x:ys, zs)\n    | otherwise = ([],xs)\n" "span" nil nil nil nil nil nil)
                       ("spf" "import System.Posix.Files" "spf" nil nil nil nil nil nil)
                       ("spio" "import System.Posix.IO" "spio" nil nil nil nil nil nil)
                       ("splitAt" "splitAt :: Eq a => Int -> [a] -> ([a],[a])\nsplitAt num xs = (take num xs, drop num xs)\n" "splitAt" nil nil nil nil nil nil)
                       ("spr" "import System.Process" "spr" nil nil nil nil nil nil)
                       ("spro" "import System.Process" "spro" nil nil nil nil nil nil)
                       ("sps" "import System.Posix.Signals" "sps" nil nil nil nil nil nil)
                       ("sr" "import System.Random\n" "sr" nil nil nil nil nil nil)
                       ("srm" "import System.Remote.Monitoring" "srm" nil nil nil nil nil nil)
                       ("ss" "import Snap.Snaplet" "ss" nil nil nil nil nil nil)
                       ("ssa" "import Snap.Snaplet.Auth" "ssa" nil nil nil nil nil nil)
                       ("ssas" "import           Snap.Snaplet.AcidState" "ssas" nil nil nil nil nil nil)
                       ("ssc" "import                Snap.Snaplet.Config" "ssc" nil nil nil nil nil nil)
                       ("ssh" "import Snap.Snaplet.Heist" "ssh" nil nil nil nil nil nil)
                       ("st" "import System.Timeout" "st" nil nil nil nil nil nil)
                       ("state" "newtype State s a = State { runState :: s -> (a,s) }\n\ninstance Functor (State s) where\n    fmap f (State g) = State $ \\initState ->\n                       let (a, newState) = g initState\n                       in (f a, newState)\n\ninstance Monad (State s) where\n    return a = State $ \\s -> (a,s)\n    f >>= g = State $ \\s -> let (a, b) = runState f s\n                            in runState (g a) b\n\nclass MonadState s a | s -> a where\n    get :: State s s\n    put :: s -> State s ()\n    modify :: (s -> s) -> State s ()\n\ninstance MonadState s (State s s) where\n    get = State $ \\s -> (s,s)\n    put s = State $ \\_ -> ((),s)\n    modify = undefined\n\nevalState :: State s a -> s -> a\nevalState act = fst . runState act\n\nexecState :: State s a -> s -> s\nexecState act = snd . runState act\n" "state" nil nil nil nil nil nil)
                       ("statefunctor" "instance Functor (State s) where\n    fmap f (State g) = State $ \\initState ->\n                       let (a, newState) = g initState\n                       in (f a, newState)\n" "statefunctor" nil nil nil nil nil nil)
                       ("statem" "newtype State s a = State { runState :: s -> (a,s) }" "statem" nil nil nil nil nil nil)
                       ("statetmonadplus" "instance (MonadPlus m) => MonadPlus (StateT s m) where\n    mzero = StateT $ \\s -> mzero\n    (StateT g) `mplus` (StateT f) = StateT $ \\s -> (g s) `mplus` (f s)\n" "statetmonadplus" nil nil nil nil nil nil)
                       ("statet" "newtype StateT s m a = StateT { runStateT :: (s -> m (a,s)) }" "statet" nil nil nil nil nil nil)
                       ("stb" "import ST.Common.Backend" "stb" nil nil nil nil nil nil)
                       ("stch" "import ST.Common.Helpers" "stch" nil nil nil nil nil nil)
                       ("sth" "import ST.Common.Helpers" "sth" nil nil nil nil nil nil)
                       ("sti" "import System.Time" "sti" nil nil nil nil nil nil)
                       ("stm" "import Control.Monad.STM" "stm" nil nil nil nil nil nil)
                       ("stricttolazy" "strictToLazy = BL.fromChunks [strict]\n" "stricttolazy" nil nil nil nil nil nil)
                       ("stv" "{-# LANGUAGE ScopedTypeVariables #-}" "stv" nil nil nil nil nil nil)
                       ("stv" "{-# LANGUAGE ScopedTypeVariables #-}" "stv" nil nil nil nil nil nil)
                       ("sufs" "import Snap.Util.FileServe\n" "sufs" nil nil nil nil nil nil)
                       ("sum" "sum :: Num a => [a] -> a\nsum = foldl (+) 0\n" "sum" nil nil nil nil nil nil)
                       ("sup" "import Snap.Util.Proxy  " "sup" nil nil nil nil nil nil)
                       ("sysd" "import System.Directory" "sysd" nil nil nil nil nil nil)
                       ("t" "Typeable" "t" nil nil nil nil nil nil)
                       ("tail" "tail :: [a] -> [a]\ntail [] = error \"empty list\"\ntail (_:xs) = xs\n" "tail" nil nil nil nil nil nil)
                       ("take" "take :: Eq a => Int -> [a] -> [a]\ntake _ []         = []\ntake n _ | n <= 0 = []\ntake n (x:xs) = x : take (n-1) xs\n" "take" nil nil nil nil nil nil)
                       ("takeWhile" "takeWhile :: (a -> Bool) -> [a] -> [a]\ntakeWhile p xs = [ z | z <- xs, p z]\n" "takeWhile" nil nil nil nil nil nil)
                       ("tbh" "import qualified Text.Blaze.Html5 as H" "tbh" nil nil nil nil nil nil)
                       ("tbha" "import qualified Text.Blaze.Html5.Attributes as A" "tbha" nil nil nil nil nil nil)
                       ("tbhrt" "import Text.Blaze.Html.Renderer.Text" "tbhrt" nil nil nil nil nil nil)
                       ("tbhru" "import qualified Text.Blaze.Html5.Renderer.Utf8 as Blaze\n" "tbhru" nil nil nil nil nil nil)
                       ("td" "threadDelay $1" "td" nil nil nil nil nil nil)
                       ("textexample" "import           Data.Text    (Text)\nimport qualified Data.Text    as T\nimport qualified Data.Text.IO as T\n\nhello :: String\nhello      = \"你好\"\nhelloBytes :: Text\nhelloBytes = T.pack hello\n\nmain = do\n    putStrLn hello\n    T.putStrLn helloBytes\n    print $ T.length helloBytes\n" "textexample" nil nil nil nil nil nil)
                       ("tf" "{-# LANGUAGE TypeFamilies #-}" "tf" nil nil nil nil nil nil)
                       ("th" "{-# LANGUAGE TemplateHaskell #-}" "th" nil nil nil nil nil nil)
                       ("tictactoe" "module TicTacToe where\n\nimport           Control.Monad.State\nimport           Data.Array\nimport           Data.List           (transpose)\ntype Board = [String]\n\n\nboard :: Board\nboard = [ \"  o\"\n        , \" x \"\n        , \"o  \" ]\n\nwinDiag :: Char -> Board -> Bool\nwinDiag k [(a:b:c:_),(h:i:j:_),(x:y:z:_)]\n    | all (==k) [a,i,z] = True\n    | all (==k) [c,i,x] = True\n    | otherwise   = False\n\nwinVert :: Char -> Board -> Bool\nwinVert x = all . all $ (==x)\n\nwinHorz :: Char -> Board -> Bool\nwinHorz x = winVert x  . transpose\n\nwin :: Char -> Board -> Bool\nwin x xs = or [winVert x xs, winHorz x xs, winDiag x xs]\n\nwinx, wino :: Board -> Bool\nwinx = win 'x'\nwino = win 'o'\n\nwinner :: Board -> IO ()\nwinner b | winx b    = print \"X wins\"\n         | wino b    = print \"O wins\"\n         | otherwise = print \"No one wins\"\n\nmain :: IO ()\nmain = winner board" "tictactoe" nil nil nil nil nil nil)
                       ("tmv" "takeMVar" "tmv" nil nil nil nil nil nil)
                       ("to" "{-# LANGUAGE TypeOperators #-}\n" "to" nil nil nil nil nil nil)
                       ("tp" "import Text.Printf\n" "tp" nil nil nil nil nil nil)
                       ("tpp" "import Text.ParserCombinators.Parsec" "tpp" nil nil nil nil nil nil)
                       ("tq" "import Test.QuickCheck" "tq" nil nil nil nil nil nil)
                       ("tqs" "import Test.QuickSpec" "tqs" nil nil nil nil nil nil)
                       ("tr" "import Text.Read " "tr" nil nil nil nil nil nil)
                       ("transpose" "transpose :: [[a]] -> [[a]]\ntranspose [] = []\ntranspose ([] : xss) = transpose xss\ntranspose ((x:xs) : xss) =\n    (x: [h | (h:_) <- xss]) : transpose (xs : [t|(_:t) <- xss])\n" "transpose" nil nil nil nil nil nil)
                       ("traversable" "class Traversable t where\n    traverse :: Applicative f => (a -> f b) -> t a -> f (t b)\n    dist :: Applicative f => t (f a) -> f (t a)\n    dist = traverse id" "traversable" nil nil nil nil nil nil)
                       ("traversablet" "instance (Traversable f) => Traversable (${1:Type}T f) where\n    traverse f ($1T a) = $2\n" "traversablet" nil nil nil nil nil nil)
                       ("traversableidentityt" "instance (Traversable f) => Traversable (IdentityT f) where\n    traverse f (IdentityT a) = IdentityT <$> traverse f a\n    " "traversableidentityt" nil nil nil nil nil nil)
                       ("traverse" "class Traversable t where\n	traverse :: Applicative f => (a -> f b) -> t a -> f (t b)\n	dist     :: Applicative f => t (f a) -> f (t a) \n	dist = traverse id\n" "traverse" nil nil nil nil nil nil)
                       ("tree" "data Tree a = Empty | Node a (Tree a) (Tree a)\n" "tree" nil nil nil nil nil nil)
                       ("treeheight" "treeHeight :: Tree a -> Int\ntreeHeight Empty = 0\ntreeHeight (Node left right) = max (treeHeight left + 1) (treeHeight right + 1)\n" "treeheight" nil nil nil nil nil nil)
                       ("treegraph" "import           Data.Graph\nimport           Data.List\nimport           Data.Tree\n\nverts = take 5 $ [ (x,x) | x <- [1..10] ]\nverts' = verts ++ take 4 [ (x+1,x) | x <- [1..10] ]\nbounds = (0,10)\ng = buildG bounds verts'\nt = Node \"h\" [\n          Node \"e\" [\n           Node \"l\" [], Node \"l\" [\n                     Node \"o\" []\n                    ]\n          ], Node \"t\" [Node \"h\" [Node \"e\" [Node \"r\" [Node \"e\" []]]]]\n         ]\n\nheight = length . levels\nmain :: IO ()\nmain = putStrLn . drawForest $ [t]\n" "treegraph" nil nil nil nil nil nil)
                       ("treeinfix" "data BinTree a = Leaf a | BinTree a :^: BinTree a\n" "treeinfix" nil nil nil nil nil nil)
                       ("treelabel" "data LabTree l a = Tip a | LFork l (LabTree l a) (LabTree l a)\n" "treelabel" nil nil nil nil nil nil)
                       ("treerose" "data RoseTree a = Node a [RoseTree a]\n" "treerose" nil nil nil nil nil nil)
                       ("tsi" "{-# LANGUAGE TypeSynonymInstances #-}" "tsi" nil nil nil nil nil nil)
                       ("tw" "toWidget" "tw" nil nil nil nil nil nil)
                       ("twb" "toWidgetBody" "twb" nil nil nil nil nil nil)
                       ("twh" "toWidgetHead" "twh" nil nil nil nil nil nil)
                       ("ty" "type ${1:Alias} = ${2:Type}" "ty" nil nil nil nil nil nil)
                       ("u" "undefined" "u" nil nil nil nil nil nil)
                       ("ui" "{-# LANGUAGE UndecidableInstances #-}" "ui" nil nil nil nil nil nil)
                       ("unboxedtype" "union Arg {\n  struct Val *boxed;     /* most values are boxed */\n  unsigned long unboxed; /* \"primitive\" values */\n};\n\ntypedef struct Val {\n  const struct ValInfo *info;\n  union Arg *args[];  /* args can be boxed or unboxed */\n} Val;\n\nUnboxed types have no constructor and cannot be thunks\nCan fit in a single register or take the place of a Val * arg\nMust extend GCInfo to identify which args are and are not boxed" "unboxedtype" nil nil nil nil nil nil)
                       ("uncurry" "uncurry :: (a -> b -> c) -> (a,b) -> c\nuncurry f (x,y) = f x y\n" "uncurry" nil nil nil nil nil nil)
                       ("uncurry11" "uncurry11 :: (a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l) ->\n           (a,b,c,d,e,f,g,h,i,j,k) -> l\nuncurry11 z (a,b,c,d,e,f,g,h,i,j,k) = z a b c d e f g h i j k\n" "uncurry11" nil nil nil nil nil nil)
                       ("unicode" "{-# LANGUAGE UnicodeSyntax #-}\n\nspherical (x, y, z) = (r, θ, φ)\n    where r = sqrt $ x^2 + y^2\n          θ = acos $ z / r\n          φ = atan2 y x\n\nπ = pi\n\n-- α = δω / δt\n" "unicode" nil nil nil nil nil nil)
                       ("replicateM" "replicateM :: Monad m => Int -> m a -> m [a]\nreplicateM num m = sequence $ replicate num m" "replicateM" nil nil nil nil nil nil)
                       ("unzip" "unzip :: [(a,b)] -> ([a],[b])\nunzip = foldr (\\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])\n  " "unzip" nil nil nil nil nil nil)
                       ("update" "$1 :: $2 -> Update DB ()\n$1 = $3" "update" nil nil nil nil nil nil)
                       ("url" "module Main where -- redundant since Main is in the default\n\nimport qualified Data.ByteString.Lazy.UTF8 as L\nimport           Data.Char\nimport           Network.HTTP.Conduit      (simpleHttp)\nimport           System.Environment\n\nmain :: IO ()\nmain = do\n  (url:_) <- getArgs\n  page <- simpleHttp url\n  putStr (L.toString page)\n" "url" nil nil nil nil nil nil)
                       ("valinfo" "typedef struct Val {\n  const struct ValInfo *info;\n  struct Val *args[];\n} Val;\n\nstruct ValInfo {\n  struct GCInfo gcInfo;  /* for garbage collector */\n  enum { THUNK, CONSTRNO, FUNC, IND } tag;\n  union {\n    Exception *(*thunk) (Val *closure);\n    unsigned int constrno;\n    Val *(*func) (const Val *closure, const Val *arg);\n  };\n};\n\ngcInfo says how many Val *s are in args and where they are\n\ntag == CONSTRNO means constrno valid, used as on last slide\n\ntag == IND means args[0] is an indirect forwarding pointer to another\n\nVal and union is unused; useful if size of args grows" "valinfo" nil nil nil nil nil nil)
                       ("vc" "verboseCheck" "vc" nil nil nil nil nil nil)
                       ("vcr" "verboseCheckResult" "vcr" nil nil nil nil nil nil)
                       ("void" "void :: Functor f => f a -> f ()\nvoid = fmap (const ())" "void" nil nil nil nil nil nil)
                       ("vp" "{-# LANGUAGE ViewPatterns #-}" "vp" nil nil nil nil nil nil)
                       ("w" "where" "w" nil nil nil nil nil nil)
                       ("websox" "import qualified Network.WebSockets as WS" "websox" nil nil nil nil nil nil)
                       ("when" "when :: Monad m => Bool -> m () -> m ()\nwhen p s  = if p then return () else s" "when" nil nil nil nil nil nil)
                       ("while" "while :: (Monad m) => m Bool -> m a -> m ()\nwhile cond action = do\n  c <- cond\n  when c $ do\n    action\n    while cond action\n" "while" nil nil nil nil nil nil)
                       ("withFile" "withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r\nwithFile name mode = bracket (openFile name mode) hClose" "withFile" nil nil nil nil nil nil)
                       ("wp" "writePtr" "wp" nil nil nil nil nil nil)
                       ("writeJSON" "writeJSON :: (MonadSnap m, ToJSON a) => a -> m ()\nwriteJSON a = do\n  modifyResponse $ setHeader \"Content-Type\" \"application/json\"\n  writeLBS . encode $ a\n" "writeJSON" nil nil nil nil nil nil)
                       ("ws" "import Web.Scotty" "ws" nil nil nil nil nil nil)
                       ("wsc" "import Web.Stripe.Customer" "wsc" nil nil nil nil nil nil)
                       ("wt" "writeText " "wt" nil nil nil nil nil nil)
                       ("wtv" "writeTVar" "wtv" nil nil nil nil nil nil)
                       ("yab" "import Yesod.Auth.BrowserId (authBrowserId)" "yab" nil nil nil nil nil nil)
                       ("yesodhello" "{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings     #-}\n{-# LANGUAGE QuasiQuotes           #-}\n{-# LANGUAGE TemplateHaskell       #-}\n{-# LANGUAGE TypeFamilies          #-}\n\nimport           Yesod\n\ndata HelloWorld = HelloWorld\n\nmkYesod \"HelloWorld\" [parseRoutes|\n/ HomeR GET\n|]\n\ninstance Yesod HelloWorld\n\ngetHomeR :: Handler RepHtml\ngetHomeR = defaultLayout [whamlet|Hello World!|]\n\nmain :: IO ()\nmain = warp 3000 HelloWorld" "yesodhello" nil nil nil nil nil nil)
                       ("yi" "{-# LANGUAGE QuasiQuotes       #-}\n{-# LANGUAGE TemplateHaskell   #-}\n\nimport Yesod\n\ndata $1 = $1\n\nmkYesod \"$1\"  [parseRoutes|\n/ HomeR GET\n|]\n\ngetHomeR  = defaultLayout [whamlet|Hello!!|]\n\nmain :: IO ()\nmain = warp 3000 $1\n\n" "yi" nil nil nil nil nil nil)
                       ("zip" "zip :: [a] -> [b] -> [(a,b)]\nzip (x:xs) (y:ys) = (x,y) : zip xs ys\nzip _ _ = []\n" "zip" nil nil nil nil nil nil)
                       ("zip3" "zip3 :: [a] -> [b] -> [c] -> [(a,b,c)]\nzip3 (x:xs) (y:ys) (z:zs) = (x,y,z) : zip3 xs ys zs\nzip3   _      _      _    = []\n" "zip3" nil nil nil nil nil nil)
                       ("zipWith" "zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys\nzipWith _ _ _ = []" "zipWith" nil nil nil nil nil nil)
                       ("zipWith" "zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys\nzipWith   _      _      _    = []\n" "zipWith" nil nil
                        ((some-var some-value))
                        nil "\"keybinding\"" nil)
                       ("zipWith3" "zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]\nzipWith3 f (x:xs) (y:ys) (z:zs) = f x y z : zipWith3 f xs ys zs\n" "zipWith3" nil nil nil nil nil nil)
                       ("zipWithM" "zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]\nzipWithM f xs ys = sequence $ zipWith f xs ys" "zipWithM" nil nil nil nil nil nil)
                       ("ziplist" "newtype ZipList a = ZipList { getZipList :: [a] }" "ziplist" nil nil nil nil nil nil)
                       ("||" "(||)                    :: Bool -> Bool -> Bool\nTrue  || _              =  True\nFalse || x              =  x" "||" nil nil nil nil nil nil)))


;;; Do not edit! File generated at Sun Sep 28 14:50:49 2014
